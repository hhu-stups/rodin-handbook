\newcommand{\varlist}[1]{\textbf{#1}}
\newcommand{\allconstants}{\varlist{c}}
\newcommand{\absvariables}{\varlist{v}}
\newcommand{\concvariables}{\varlist{w}}
\newcommand{\allvariables}{{\absvariables,\concvariables}}
\newcommand{\absparameters}{\varlist{t}}
\newcommand{\concparameters}{\varlist{u}}
\newcommand{\allparameters}{{\absparameters,\concparameters}}

\section{Event-B (Modeling notation)}
\label{reference_02}

In Event-B, we have two types of components: contexts and machines.
Here we describe briefly the different elements of a context or machine.
We do not use a specific syntax for describing the components because this depends on the editor that is
used. The default editor enforces a structure which contains the elements that are described here.

Proof obligations are generated to guarantee certain properties of the modeled system.
We explain here which proof obligations are generated and for each we list the goal and hypotheses that can be used
when performing the proof.
This is done in the form:
\podef{Description}{Label of the proof obligation (\eventbpo{label} refers to the label of the resp. 
  axiom/invariant/guard/etc.)}{Goal that should be proved}{Hypotheses that can be used}

\subsection{About the notation that we use}
(Variable substitution)

We denote a sequence of identifiers with $\varlist{x} = x_1,\ldots,x_n$ and $\varlist{x}' = x'_1,\ldots,x'_n$
As a convention, we use
\begin{itemize}
\item $\allconstants$ for constants
\item $\absvariables$ and $\concvariables$ for abstract variables and concrete variables
\item $\absparameters$ and $\concparameters$ for abstract and concrete parameters
\end{itemize}

\subsection{Contexts}
\index{context}
A context describes the static part of a model. It consists of
\begin{itemize}
\item Carrier sets
\item Constants
\item Axioms
\item Extended contexts
\end{itemize}

\subsubsection{Carrier Sets}
\label{sets}
\index{carrier set}
A new data type can be declared by adding its name -- an identifier -- to the \eventbsection{Sets} section.
The identifier must be unique, i.e. it must not have been already declared as a constant or set in an extended context.
The identifier is then implicitly introduced as a new constant (see below) that represents the set of all elements of the type. 

A common pattern for declaring enumerated sets (sets where all elements are explicitly given)
is to use the partition operator. If we want to specify a set $S$ with elements $e_1,\ldots,e_n$,
we declare $S$ as a set, $e_1,\ldots,e_n$ as constants and add the axiom $partition(S,e_1,\ldots,e_n)$.

\subsubsection{Extending a context}
Other contexts can be extended by adding their name to the \eventbsection{Extends} section.

The resulting context consists of all constants and axioms of all extended contexts and the extending context itself.
Thus for a context or machine that extends resp. sees the contexts, it makes no difference where a constant or axiom is declared.

It is an error to extend two contexts which declare a constant or set of the same name.

\subsubsection{Constants and axioms}
\label{constants_and_axioms}
\index{constant}
\index{axiom}
Constants can be declared by adding their unique name (an identifier) to the \eventbsection{Constants} section.
The type of the constant must be inferable by the axioms.
We denote the sequence of all constants with $\varlist{c}$.

An axiom describes a statement that can be assumed as true in the rest of the model.
Each axiom consists of a label and a predicate $A(\varlist{c})$.

\index{theorem!axiom@axiom as theorem}
An axiom $A_{thm}$ can be marked as a theorem. In that case the following proof obligation is created:
%\podef{Proof obligation of a theorem}{\eventbpo{label/THM}}{the theorem}{axioms defined before the theorem and in extended contextes}
\pode{Proof obligation of a theorem}{\eventbpo{label/THM}}{$A_b(\allconstants) \limp A_{thm}(\allconstants)$}
where $A_b$ denotes (the conjunction of) all axioms declared in extended contexts or before the theorem in the current context.

If an axiom $A$ contains any condition that is well-defined, a proof obligation is generated:
%\podef{Well-definedness of an axiom}{\eventbpo{label/WD}}{The axiom's WD-condition}{axioms defined before the theorem and in extended contextes}
\pode{Well-definedness of an axiom}{\eventbpo{label/WD}}{$A_b(\allconstants) \limp \wdl(A(\allconstants))$}.


\subsection{Machines}
\index{machine}
A machine describes the dynamic behavior of a model by means of variables whose values are changed by events.

There are two basic things that must be proven for a machine. First that the machine is
consistent, i.e. that it could never reach a state which violates the invariant. Second,
that the machine is a correct refinement, i.e. that its behavior corresponds to the
refined machine.

\subsubsection{Refinement}
A machine can refine at most one other machine. 
We call the refined machine the abstract machine whereas the refinement is the more concrete machine. 
More generally, a machine $M_0$ can be refined by machine $M_1$, $M_1$ refined by $M_2$ 
and so on until the most concrete refinement $M_n$. 

Basically a refinement has two aspects. First, the concrete machine's state is related to the state of the
abstract machine by a \emph{gluing invariant}. Second, each abstract event can be refined by one or more
concrete events.

The invariant is used to relate abstract and concrete variables. Invariants of a concrete machine are also called gluing invariants.
The full invariant of the machine contains both abstract and concrete invariants. 
The invariants are accumulated during refinements.

\subsubsection{Seeing a context}
If the machine sees a context, its declared sets and constants can be used in
 all predicates and expressions.
The conjunction of axioms $A(\allconstants)$ can be used as hypothesis in the proofs.

\subsubsection{Variables and invariants}
\index{variable}
Variables can be declared by adding their unique name (an identifier) to the \eventbsection{Variables}.
The type of the variable must be inferable by the invariants of the machine.
We denote the variables of the abstract machines $M_1,\ldots,M_{n-1}$ with $\absvariables$ and
the variables of the concrete machine $\concvariables$.

\index{invariant}
An invariant describes a statement that should be hold in each state of the machine.
Each invariant $i$ consists of a label and a predicate $I_i(\allconstants,\absvariables,\concvariables)$.
Beside constants, an invariant can refer to variables of the concrete and all abstract machines.

We write $I(\allconstants,\absvariables,\concvariables)$ for the conjunction of all invariants
of the machine and all its abstract machines. We call this the invariant of the machine.

\index{theorem!invariant@invariant as theorem}
An invariant $I_{thm}(\allconstants,\absvariables,\concvariables)$ can be marked as a theorem. In that case the following proof obligation is generated:
\pode{An invariant as theorem}{\eventbpo{label/THM}}{$A(\allconstants) \land I_b(\allconstants,\absvariables,\concvariables) \limp I_{thm}(\allconstants,\absvariables,\concvariables)$}
where $I_b$ denotes (the conjunction of) all invariants declared in abstract machines or before
the theorem in the concrete machine.

Invariant preservation of events does not need to be proven for invariants that are marked as theorems, because
 their correctness results from the preservation of the other invariants (see below for details).

If an invariant $I_i$ contains a well-definedness condition, the following proof obligation is created:
\pode{Well-definedness of an invariant}{\eventbpo{label/WD}}{$A(\allconstants) \land I_b(\allconstants,\absvariables,\concvariables) \limp \wdl(I_i(\allconstants,\absvariables,\concvariables))$}

\paragraph{Common variables between machines}
\index{variable!common@common variable}
With some restrictions can the abstract variables $\absvariables$ and concrete
  variables $\concvariables$ have variables in common.
If a variable $v$ is declared in a machine $M_i$, it can be re-used in the
  direct refinement $M_{i+1}$. 
In that case it is assumed that the values of the abstract and concrete variable 
  are always equal.
To ensure this, special proof obligations are generated. (see below in section \ref{events})
Once a variable disappears in a refinement, e.g. is not declared in machine $M_{i+2}$,
  it cannot be re-introduced in a later refinement.

\subsubsection{Events (without refinement)}
\label{events_no_refinement}
\index{event}
A possible state change of a machine is defined by an event.
The condition under which an event can happen is given by a guard, the event's action
describe how the new and old state relate to each other.

Events occur atomically, i.e. one event happens at a time, leading to a new state.
Two events never happen at the same time. There is also no notion of time that elapses
during the event happening.

An event has the following elements:
\begin{itemize}
\item Name
\item Parameters
\item Guards
\item Witnesses
\item Actions
\item Status (ordinary, convergent or anticipated)
\end{itemize}

An event can refine one or more events of an abstract machine. To keep things simple, we
  first consider only events that do not refine other events.

\paragraph{Parameters}
\index{parameter}
An event may have an arbitrary number of \emph{parameters}. Their names must be unique. 
I.e. there must be constant or variable with the same name.
The types of the parameters must be inferable by the guards of the event.
We denote the parameters of a concrete event with $\concparameters$.

\paragraph{Guards}
\index{guard}
Each \emph{guard} of consist of a label and a predicate $G(\allconstants,\concvariables,\concparameters)$.
Variables or parameters of abstract machines are not accessible in a guard.

Like axioms and invariants, guards can be marked as theorems, too. The following
proof obligation is generated where $G_b$ denotes the (conjunction of) the guards occurring before the theorem:
%\podef{A guard as theorem}{\eventbpo{eventname/label/THM}}{the theorem}{axioms of seen contexts, invariants 
%  (also of refined machines), guards of the event that are declared before the theorem}
\pode{A guard as theorem}{\eventbpo{eventname/guardlabel/THM}}%
{$A(\allconstants) \land I(\allconstants,\absvariables,\concvariables) \land G_b(\allconstants,\concvariables,\concparameters) 
\limp G_{thm}(\allconstants,\concvariables,\concparameters)$}
If the guard $G_i$ contains WD-conditions, the following proof obligation is generated:
\pode{WD-condition of a guard}{\eventbpo{eventname/guardlabel/WD}}%
{$A(\allconstants) \land I(\allconstants,\absvariables,\concvariables) \land G_b(\allconstants,\concvariables,\concparameters) 
\limp \wdl(G_i(\allconstants,\concvariables,\concparameters))$}

\paragraph{Actions}
\label{actions}
An action consists of a label and an assignment.
An assignment can have one of the following forms:
\begin{itemize}
\item $x_1,\ldots,x_n \bcmeq E_1(\allconstants,\concvariables,\concparameters),\ldots,E_n(\allconstants,\concvariables,\concparameters)$ \\
  where $E_i$ is an expression that denotes the new value of the concrete variable $x_i$.
  $E_i$ has same type as $x_i$.
\item $x(F(\allconstants,\concvariables,\concparameters)) \bcmeq E(\allconstants,\concvariables,\concparameters)$ \\
  where $x$ is a concrete variable that is a relation.
  In the new state $x$ maps $F(\allconstants,\concvariables,\concparameters)$ to $E(\allconstants,\concvariables,\concparameters)$.
  $x$ has the type $\pow(\alpha\cprod\beta)$, $F$ the type $\alpha$ and $E$ the
  type $\beta$.
\item $x \bcmin E(\allconstants,\concvariables,\concparameters)$ \\
  assigns the concrete variable $x$ a new value of the set $E(\allconstants,\concvariables,\concparameters)$.
  $x$ is of type
  $\alpha$ and $E(\allconstants,\concvariables,\concparameters)$ of type $\pow(\alpha)$.
\item $x_1,\ldots,x_n \bcmsuch Q(\allconstants,\concvariables,\concparameters,x_1',\ldots,x_n')$ \\
  where $Q$ is a before-after-predicate that describes possible new states.
  $x_1,\ldots,x_n$ refer to the values of variable in the state before the event occurs,
  $x_1',\ldots,x_n'$ to the values in the new state after the event.
\end{itemize}
The first two form of assignment are deterministic assignments, because 
  there is exactly one possible new value for fixed values for variables and parameters.
Accordingly the third and fourth form are non-deterministic.
The last form is the most general one and the others can be translated into it:
\begin{itemize}
\item $x(F(\allconstants,\concvariables,\concparameters)) \bcmeq E(\allconstants,\concvariables,\concparameters)
  \quad\defi\quad 
  x \bcmeq x \ovl \{~F(\allconstants,\concvariables,\concparameters) \mapsto E(\allconstants,\concvariables,\concparameters)~\}$
\item $x_1,\ldots,x_n \bcmeq E_1(\allconstants,\concvariables,\concparameters),\ldots,E_n(\allconstants,\concvariables,\concparameters)
  \quad\defi\quad
  x_1,\ldots,x_n \bcmsuch x_1' = E_1(\allconstants,\concvariables,\concparameters) \land \ldots \land x_n' = E_n(\allconstants,\concvariables,\concparameters)$
\item $x \bcmin E(\allconstants,\concvariables,\concparameters) 
  \quad\defi\quad
  x' \in E(\allconstants,\concvariables,\concparameters)$
\end{itemize}
To avoid ambiguities a variable can only be assigned once in an action, i.e. all identifiers 
  of the left side of $\bcmsuch$ must be distinct.
If an action has more than one action, they are executed in parallel. Again, it is an error
  to assign to a variable in more than one action.
All variables that are not assigned to in an action, keep the same value in new and old state.

\paragraph{Initialization}
\index{initialization}
The initialization of a machine is given by a special event, called \textsl{INITIALISATION}.
Unlike in other events, the initialization must not contain guards and parameters.
The actions must not make use of variable values before the initialization event occurs.
All variables must be assigned a value to. If there is no assignment for the variable $x$,
Rodin assumes a default assignment of the form $x\bcmsuch \btrue$.

\paragraph{Well-definedness of assignments}
\label{welldefinedness_of_assignments}
\index{well definedness!of assignments}
The well-definedness conditions of the assignments are: \\
$\wdl(~x_1,\ldots,x_n \bcmeq E_1(\allconstants,\concvariables,\concparameters),\ldots,E_n(\allconstants,\concvariables,\concparameters)~)
  \quad\defi\quad 
  \wdl(E_1(\allconstants,\concvariables,\concparameters)) \land \ldots \land \wdl(E_n(\allconstants,\concvariables,\concparameters))$ \\
$\wdl(~x(F(\allconstants,\concvariables,\concparameters)) \bcmeq E(\allconstants,\concvariables,\concparameters)~)
  \quad\defi\quad 
  \wdl(F(\allconstants,\concvariables,\concparameters)) \land \wdl(E(\allconstants,\concvariables,\concparameters))$ \\
$\wdl(~x \bcmin E(\allconstants,\concvariables,\concparameters)~)
  \quad\defi\quad
  \wdl(E(\allconstants,\concvariables,\concparameters))$\\
$\wdl(~x_1,\ldots,x_n \bcmsuch Q(\allconstants,\concvariables,\concparameters,x_1',\ldots,x_n')~)
  \quad\defi\quad
  \wdl(Q(\allconstants,\concvariables,\concparameters,x_1',\ldots,x_n'))$
\paragraph{Proof obligations}
The following proof obligations are generated for events:

Every action $a$ with label $\eventbpo{actionlabel}$ of an event must be well-defined.
  \pode{Well-definedness of actions}%
  {\eventbpo{eventlabel/actionlabel/WD}}%
  {$A(\allconstants) \land I(\allconstants,\allvariables) \land G(\allconstants,\concvariables,\concparameters) \limp %
    \wdl(~a~)$}
  

If the event's guard is enabled, every action must be feasible.
  This trivially true in the case of the deterministic assignments.
  For $x \bcmin E(\allconstants,\concvariables,\concparameters)$ it must be proven that the
  set $E$ is not empty:
  \pode{Action feasibility (for $\bcmin$)}{\eventbpo{eventlabel/actionlabel/FIS}}%
  {$A(\allconstants) \land I(\allconstants,\allvariables) \land G(\allconstants,\concvariables,\concparameters) \limp %
    E(\allconstants,\concvariables,\concparameters) \neq \emptyset$}
  For $x_1,\ldots,x_n \bcmsuch Q(\allconstants,\concvariables,\concparameters,x_1',\ldots,x_n')$
  values must exist that fulfill $Q$:
  \pode{Action feasibility (for $\bcmsuch$)}{\eventbpo{eventlabel/actionlabel/FIS}}%
  {$A(\allconstants) \land I(\allconstants,\allvariables) \land G(\allconstants,\concvariables,\concparameters) \limp %
    \exists x_1',\ldots,x_n' \qdot Q(\allconstants,\concvariables,\concparameters,x_1',\ldots,x_n')$}  

For each invariant $I_i$ with label \eventbpo{invlabel} 
  that contains a variable that is affected by the assignment, it must be proven
  that the invariant still holds with the new values.
  \pode{Invariant preservation}%
  {\eventbpo{eventlabel/invlabel/INV}}%
  {$A(\allconstants) \land I(\allconstants,\allvariables) \land G(\allconstants,\concvariables) \limp I_i(\allconstants,\allvariables')$}
  Rodin simplifies this proof obligations by replacing $x'$ by $x$ for variables that are not
  changed and $x'$ by $E(\allconstants,\concvariables,\concparameters)$ 
  for variables that are assigned by an deterministic ($x \bcmeq E$) assignment.

For the initializations we have the following special cases:
  \pode{Action feasibility (for $\bcmin$ in initialization)}{\eventbpo{INITIALISATION/actionlabel/FIS}}%
  {$A(\allconstants) \limp  E(\allconstants) \neq \emptyset$}
  \pode{Action feasibility (for $\bcmsuch$ in INITIALISATION)}{\eventbpo{INITIALISATION/actionlabel/FIS}}%
  {$A(\allconstants) \limp \exists x_1',\ldots,x_n' \qdot Q(\allconstants,x_1',\ldots,x_n')$}  
  \pode{Invariant preservation (in INITIALISATION)}%
  {\eventbpo{INITIALISATION/invlabel/INV}}%
  {$A(\allconstants) \limp I_i(\allconstants,\allvariables')$}

\subsubsection{Refinement of events}
\label{refinement_of_events}
An event can refine one or more events of the abstract machine.
We first consider only the refinement of at most one event. 
For refining more than one event -- called merging events --, please see below in section~\ref{merging_events}.

\paragraph{Witnesses}
Witnesses consists of a label and a predicate that are used to establish a link between values 
  of variables and parameters of the concrete and abstract events.
\warning{Unlike other elements in Event-B that have a label, the label of a witness has a meaning
  and cannot be chosen arbitrarily.}
If the user does not specify a witness, Rodin uses the default witness $\btrue$.

Witnesses are necessary in the following circumstances:
\begin{itemize}
\item The abstract event has a parameter $p$ that is not a parameter of the concrete
  event.
  The label of the witness must be $p$.
  The witness has the form $W(\allconstants,\allvariables,\concparameters,p)$.
  (TODO: I did not check this, might be slightly different)
\item The abstract event assigns non-deterministically (using $\bcmin$ or $\bcmsuch$) 
  a value to a variable $x$ that is not a variable of the concrete machine.
  The label of the witness must be $x'$.
  The witness has the form $W(\allconstants,\allvariables,\allparameters,x')$.
\end{itemize}

It must be proven that a witness is satisfiable, $\Box$ denotes the parameter $p$ or variable $v'$ that
  the witness is written for.
\pode{Witness feasibility}{\eventbpo{eventlabel/witnesslabel/WFIS}}%
  {$A(\allconstants) \land I(\allconstants,\absvariables) \land J(\allconstants,\allvariables) \land
    T(\allconstants,\concparameters,\concvariables,\concvariables') \limp
    W(\allconstants,\allvariables,\allparameters,\Box)$}
A witness $W(\allconstants,\allvariables,\allparameters,\Box)$ may contain well-definedness conditions.
\pode{Well-definedness of a witness}{\eventbpo{eventlabel/witnesslabel/WWD}}%
  {TODO}

A concrete event must only be enabled if the abstract event is enabled.
This condition is called \emph{guard strengthening}.


\subsubsection{Merging events}
\label{merging_events}
(This section will be written in a later iteration.)

\subsubsection{Termination}
\label{termination}
(This section will be written in a later iteration.)

  
\subsection{Generated proof obligations}

We give a brief overview about what POs are generated where. This should help the user to identify the reason of a PO when he just know its label.

\marginpar{CONTENT MIGRATED FROM WIKI!}

Proof obligations (abbreviated as PO) are generated by the proof obligation generator and have the form of Sequents. 

The following tables list the different PO and their associated name.

Next is a table describing the names of context proof obligations: 

\begin{center}
    \begin{tabular}{| p{6cm} | p{3cm} | p{5cm} |}
    \hline
	Well-definedness of an Axiom & $m$ / WD & $m$ is the axiom name\\ \hline
	Well-definedness of a Derived Axiom & $m$  / WD & $m$ is the axiom name \\ \hline
	Derived Axiom & $m$  / THM & $m$ is the axiom name \\ \hline
    \end{tabular}
\end{center}

Next is a table showing the name of machine proof obligations:

\begin{center}
    \begin{tabular}{| p{6cm} | p{3cm} | p{5cm} |}
    \hline
	Well-definedness of an Invariant & $v$  / WD & $v$ is the invariant name\\ \hline
	Well-definedness of a Derived Invariant & $m$  / WD & $m$ is the invariant name \\ \hline
	Well-definedness of an event Guard & $t$  / $d$  / WD & $t$ is the event name, $d$ is the action name  \\ \hline
	Well-definedness of an event Action & $t$  / $d$  / WD & $t$ is the event name, $d$ is the action name  \\ \hline
	Feasibility of a non-det. event Action & $t$  / $d$  / FIS & $t$ is the event name, $d$ is the action name  \\ \hline
	Derived Invariant & $m$ / THM & $m$ is the invariant name \\ \hline
	Invariant Establishment & INIT.  / $v$  / INV & $v$ is the invariant name  \\ \hline
	Invariant Preservation & $t$  / $v$  / INV & $t$ is the event name, $v$ is the invariant name  \\ \hline
    \end{tabular}
\end{center}

Next are the proof obligations concerned with machine refinements:

\begin{center}
    \begin{tabular}{| p{6cm} | p{3cm} | p{5cm} |}
    \hline
	Guard Strengthening & $t$  / $d$  / GRD & $t$ is the concrete event name, $d$ is the abstract guard name\\ \hline
	Guard Strengthening (merge) & $t$  / MRG & $t$ is the concrete event name \\ \hline
	Action Simulation & $t$  / $d$  / SIM & $t$ is the concrete event name, $d$ is the abstract action name  \\ \hline
	Equality of a preserved Variable & $t$  / $v$  / EQL & $t$ is the concrete event name, $v$ is the preserved variable  \\ \hline
    \end{tabular}
\end{center}

Next are the proof obligations concerned with the new events variant:

\begin{center}
    \begin{tabular}{| p{6cm} | p{3cm} | p{5cm} |}
    \hline
	Well definedness of Variant & VWD & \\ \hline
	Finiteness for a set Variant & FIN &  \\ \hline
	Natural number for a numeric Variant & $t$  / NAT & $t$ is the new event name \\ \hline
	Decreasing of Variant & $t$  / VAR & $t$ is the new event name  \\ \hline
    \end{tabular}
\end{center}

Finally, here are the proof obligations concerned with witnesses:

\begin{center}
    \begin{tabular}{| p{6cm} | p{3cm} | p{5cm} |}
    \hline
	Well definedness of Witness & $t$  / $p$  / WWD & $t$ is the concrete event name, $p$ is parameter name, or a primed variable name \\ \hline
	Feasibility of non-det. Witness & $t$  / $p$  / WFIS & $t$ is the concrete event name, $p$ is parameter name, or a primed variable name \\ \hline
    \end{tabular}
\end{center}

Remark: At the moment, the deadlock freeness proof obligation generation is missing. If you need it, you can generate it yourself as a derived invariant saying the the disjunction of the abstract guards imply the disjunction of the concrete guards.

\subsection{Visibility of identifiers}
\label{visibility_of_identifiers}

This table shows which identifiers can be used in predicates or expressions. 
\begin{description}
\item[Sets] Set that are defined in the context (in case of an axiom) or in a seen context.
  If a context extends another context, the sets of the extended context are treated as if they
  are defined in the extending context.
\item[Constants] Like the sets, a constant that is defined in the context (in case of an axiom) or
  in a seen context.
\item[Concrete Variables] Variables that are defined in the machine itself. This does \emph{not}
  include variables of refined machines.
\item[Abstract Variables] Variables that are defined in an abstract machine.
\item[Concrete Parameters] Parameters that are defined in the event itself. This does \emph{not}
  include parameters of refined events.
\item[Abstract Parameters] Parameters that are defined in an abstract event.
\end{description}

\begin{center}
  \newcommand{\markcell}{$\times$}
  \begin{tabular}{lcccccc}
  \hline
            &           &           & concrete  & abstract  & concrete   & abstract \\
            & sets      & constants & variables & variables & parameters & parameters \\
  \hline
  axiom     & \markcell & \markcell &           &           &            & \\
  invariant & \markcell & \markcell & \markcell & \markcell &            & \\
  variant   & \markcell & \markcell & \markcell & \markcell &            & \\
  guard     & \markcell & \markcell & \markcell & \markcell & \markcell  & \\
  witness$^{*}$   & \markcell & \markcell & \markcell & \markcell & \markcell  & \markcell \\
  action$^{*}$    & \markcell & \markcell & \markcell & \markcell & \markcell  &  \\
  \hline
  \end{tabular}    
\end{center}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "rodin-doc"
%%% End: 
