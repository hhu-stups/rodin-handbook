\newcommand{\varlist}[1]{\mathbf{#1}}
\newcommand{\allconstants}{\varlist{c}}
\newcommand{\absvariables}{\varlist{v}}
\newcommand{\concvariables}{\varlist{w}}
\newcommand{\allvariables}{{\absvariables,\concvariables}}
\newcommand{\absparameters}{\varlist{t}}
\newcommand{\concparameters}{\varlist{u}}
\newcommand{\allparameters}{{\absparameters,\concparameters}}
\newcommand{\absbeforeafter}{\mathcal{S}}
\newcommand{\concbeforeafter}{\mathcal{T}}

\section{Event-B (Modeling notation)}
\label{reference_02}

In Event-B, we have two types of components: contexts and machines.
Here we describe briefly the different elements of a context or machine.
We do not use a specific syntax for describing the components because the syntax is dependent on the editor that is
used. The default editor requires a structure which contains the elements that are described here.

Proof obligations are generated to guarantee certain properties of the modeled system.
We will explain here which proof obligations are generated and we will list the goal and hypotheses that can be used
when performing the proof for each one.
This is done in the form:
\podef{Description}{Label of the proof obligation (\eventbpo{label} refers to the label of the respective 
  axiom/invariant/guard/etc.)}{Goal that should be proved}{Hypotheses that can be used}

\subsection{About the notation that we use}
(Variable substitution)

We denote a sequence of identifiers with $\varlist{x} = x_1,\ldots,x_n$ and $\varlist{x}' = x'_1,\ldots,x'_n$
As a convention, we use
\begin{itemize}
\item $\allconstants$ for constants
\item $\absvariables$ and $\concvariables$ for abstract variables and concrete variables
\item $\absparameters$ and $\concparameters$ for abstract and concrete parameters
\end{itemize}

\subsection{Contexts}
\index{context}
A context describes the static part of a model. It consists of
\begin{itemize}
\item Carrier sets
\item Constants
\item Axioms
\item Extended contexts
\end{itemize}

\subsubsection{Carrier Sets}
\label{sets}
\index{carrier set}
A new data type can be declared by adding its name -- an identifier -- to the \eventbsection{Sets} section.
The identifier must be unique, i.e. it must not have been already declared as a constant or set in an extended context.
The identifier is then implicitly introduced as a new constant (see below) that represents the set of all elements of the type. 

A common pattern for declaring enumerated sets (sets where all elements are explicitly given)
is to use the partition operator. If we want to specify a set $S$ with elements $e_1,\ldots,e_n$,
we declare $S$ as a set, $e_1,\ldots,e_n$ as constants and add the axiom $partition(S,e_1,\ldots,e_n)$.

\subsubsection{Extending a context}
Other contexts can be extended by adding their name to the \eventbsection{Extends} section.

The resulting context consists of all constants and axioms of all extended contexts and the extending context itself.
Thus for a context or machine that extends or sees the contexts, it makes no difference where a constant or axiom is declared.

Extending two contexts which declare a constant or set using the same identifier will result in an error.

\subsubsection{Constants and axioms}
\label{constants_and_axioms}
\index{constant}
\index{axiom}
Constants can be declared by adding their unique name (an identifier) to the \eventbsection{Constants} section.
An axiom must also be in place from which the type of the constant can be inferred.
We denote the sequence of all constants with $\varlist{c}$.

An axiom is a statement that is assumed as true in the rest of the model.
Each axiom consists of a label and a predicate $A(\varlist{c})$.

\index{theorem!axiom@axiom as theorem}
An axiom $A_{thm}$ can be marked as a theorem. In that case the following proof obligation is created:
%\podef{Proof obligation of a theorem}{\eventbpo{label/THM}}{the theorem}{axioms defined before the theorem and in extended contextes}
\pode{Proof obligation of a theorem}{\eventbpo{label/THM}}{$A_b(\allconstants) \limp A_{thm}(\allconstants)$}
where $A_b$ denotes (the conjunction of) all axioms declared in extended contexts and the axioms already declared in the current context before the theorem in question.

If an axiom $A$ contains any condition that is well-defined, a proof obligation is generated:
%\podef{Well-definedness of an axiom}{\eventbpo{label/WD}}{The axiom's WD-condition}{axioms defined before the theorem and in extended contextes}
\pode{Well-definedness of an axiom}{\eventbpo{label/WD}}{$A_b(\allconstants) \limp \wdl(A(\allconstants))$}.


\subsection{Machines}
\index{machine}
A machine describes the dynamic behavior of a model by means of variables whose values are changed by events.

There are two basic things that must be proven for a machine:
\begin{enumerate}
	\item The machine must be consistent, i.e. it should never reach a state which violates the invariant.
	\item The machine is a correct refinement, i.e. its behavior must correspond to any machines that it refines
\end{enumerate}

\subsubsection{Refinement}
A machine can only refine one other machine. 
We refer to the refined machine as the abstract machine and refer to the refinement as the concrete machine. 
More generally, a machine $M_0$ can be refined by machine $M_1$, $M_1$ refined by $M_2$ 
and so on. The most concrete refinement would be $M_n$. 

Basically, a refinement consists of two aspects:
\begin{enumerate}
	\item The concrete machine's state is connected to the state of the
abstract machine. To do this, an invariant is used to relate abstract and concrete variable. This invariant is called a \emph{gluing invariant}. 
	\item Each abstract event can be refined by one or more
concrete events.
\end{enumerate}

The full invariant of the machine contists of both abstract and concrete invariants. 
The invariants are accumulated during refinements.

\subsubsection{Seeing a context}
If the machine sees a context, the sets and constants declared in the context can be used in
 all predicates and expressions.
The conjunction of axioms $A(\allconstants)$ can be used as hypotheses in the proofs.

\subsubsection{Variables and invariants}
\index{variable}
Variables can be declared by adding their unique name (an identifier) to the \eventbsection{Variables} section. The invariants of the machine must make the type of the variable clear.
We denote the variables of the abstract machines $M_1,\ldots,M_{n-1}$ with a $\absvariables$ and the variables of the concrete machine with a $\concvariables$.

\index{invariant}
An invariant is a statement that must hold at each state of the machine.
Each invariant $i$ consists of a label and a predicate $I_i(\allconstants,\absvariables,\concvariables)$.
An invariant can refer to the constants as well as the variables of the concrete and all abstract machines.

We write $I(\allconstants,\absvariables,\concvariables)$ to denote the conjunction of all invariants
of the machine and all its abstract machines. We call this the invariant of the machine.

\index{theorem!invariant@invariant as theorem}
An invariant $I_{thm}(\allconstants,\absvariables,\concvariables)$ can be marked as a theorem. In this case, the following proof obligation is generated:
\pode{An invariant as theorem}{\eventbpo{label/THM}}{$A(\allconstants) \land I_b(\allconstants,\absvariables,\concvariables) \limp I_{thm}(\allconstants,\absvariables,\concvariables)$}
where $I_b$ denotes (the conjunction of) all invariants declared in abstract machines and all invariants declared in the concrete machine before
the theorem in question.

Invariants that are marked as theorems derive their correctness from the preservation of other invariants (see below for details), so their preservation does not need to be proven.

If an invariant $I_i$ contains a well-definedness condition, the following proof obligation is generated:
\pode{Well-definedness of an invariant}{\eventbpo{label/WD}}{$A(\allconstants) \land I_b(\allconstants,\absvariables,\concvariables) \limp \wdl(I_i(\allconstants,\absvariables,\concvariables))$}

\paragraph{Common variables between machines}
\index{variable!common@common variable}
With some restrictions, the abstract variables $\absvariables$ and concrete
  variables $\concvariables$ can have variables in common.
If a variable $v$ is declared in a machine $M_i$, it can be re-used in the
  direct refinement $M_{i+1}$. 
In that case, it is assumed that the values of the abstract and concrete variable 
  are always equal.
To ensure this, special proof obligations are generated (see below in section \ref{events}).
Once a variable disappears in a refinement, i.e. is not declared in machine $M_{i+2}$,
  it cannot be re-introduced in a later refinement.

\subsubsection{Events}
\label{events}
\index{event}
A possible state change of a machine is defined by an event.
The condition under which an event can happen is given by a guard, the event's action
describe how the new and old state relate to each other.

Events occur atomically, i.e. one event happens at a time, leading to a new state.
Two events never happen at the same time. There is also no notion of time that elapses
during the event happening.

An event has the following elements:
\begin{itemize}
\item Name
\item Parameters
\item Guards
\item Witnesses
\item Actions
\item Status (ordinary, convergent or anticipated): The status is used
  for termination proofs (see section~\ref{termination} for details).
\end{itemize}

An event can refine one or more events of an abstract machine. To keep things simple, we
  first consider only events that have at most one refined event.
If there are several refinement steps -- e.g. event $E_1$ is refined by $E_2$ and $E_2$ by
  $E3$, we call $E_1$ and $E_2$ the abstract events and $E_3$ the concrete event.
Likewise, if we refer e.g. to the parameters of the abstract events, we mean all parameters
  of $E_1$ and $E_2$.

\paragraph{Parameters}
\index{parameter}
An event may have an arbitrary number of \emph{parameters}. Their names must be unique. 
I.e. there must be no constant or variable with the same name.
The types of the parameters must be inferable by the guards of the event.
We denote the parameters of all abstract events with $\absparameters$, the
parameters of the concrete event with $\concparameters$.

Analogously to variables, an event can have parameters in common with the event it refines.
If the refined event has a parameter $t$ which is not a parameter of the refinement, 
a witness $W(\allconstants,\allvariables,\concparameters,t)$ for the abstract parameter must be specified (see below).

\paragraph{Guards}
\index{guard}
Each \emph{guard} consist of a label and a predicate $H(\allconstants,\concvariables,\concparameters)$.
Variables or parameters of abstract machines are not accessible in a guard.

We write $G(\allconstants,\absvariables,\absparameters)$ for the (conjunction of) all guards of all refined events.

\marginpar{Check the proof obligations and text for the role of witnesses and in the case of refinement}
Like axioms and invariants, guards can be marked as theorems, too. The following
proof obligation is generated where $G_b$ denotes the (conjunction of) the guards occurring before the theorem:
%\podef{A guard as theorem}{\eventbpo{eventname/label/THM}}{the theorem}{axioms of seen contexts, invariants 
%  (also of refined machines), guards of the event that are declared before the theorem}
\pode{A guard as theorem}{\eventbpo{eventname/guardlabel/THM}}%
{$A(\allconstants) \land I(\allconstants,\absvariables,\concvariables) \land G_b(\allconstants,\concvariables,\concparameters) 
\limp G_{thm}(\allconstants,\concvariables,\concparameters)$}
If the guard $G_i$ contains WD-conditions, the following proof obligation is generated:
\pode{WD-condition of a guard}{\eventbpo{eventname/guardlabel/WD}}%
{$A(\allconstants) \land I(\allconstants,\absvariables,\concvariables) \land G_b(\allconstants,\concvariables,\concparameters) 
\limp \wdl(G_i(\allconstants,\concvariables,\concparameters))$}


\paragraph{Actions}
\label{actions}
An action consists of a label and an assignment.
Section~\ref{assignments} gives an overview over the assignments.
They can be put into two groups: deterministic and non-deterministic assignments.
Each assignment affects one or more concrete variables.

If an action has more than one action, they are executed in parallel. 
It is an error to assign to a variable in more than one action.
All variables that are not assigned to in an action, keep the same value in new and old state.

\paragraph{Witnesses}
Witnesses consists of a label and a predicate that are used to establish a link between values 
  of variables and parameters of the concrete and abstract events.
\warning{Unlike other elements in Event-B that have a label, the label of a witness has a meaning
  and cannot be chosen arbitrarily.}
If the user does not specify a witness, Rodin uses the default witness $\btrue$.

Witnesses are necessary in the following circumstances:
\begin{itemize}
\item The abstract event has a parameter $p$ that is not a parameter of the concrete
  event.
  The label of the witness must be $p$.
  The witness has the form $W(\allconstants,\allvariables,\concparameters,p)$.
  (TODO: I did not check this, might be slightly different)
\item The abstract event assigns non-deterministically (using $\bcmin$ or $\bcmsuch$) 
  a value to a variable $x$ that is not a variable of the concrete machine.
  The label of the witness must be $x'$.
  The witness has the form $W(\allconstants,\allvariables,\allparameters,x')$.
\end{itemize}

It must be proven that a witness is satisfiable, $x$ is a place-holder for the parameter $p$
  or variable $v'$ that the witness is written for.
\pode{Witness feasibility}{\eventbpo{eventlabel/witnesslabel/WFIS}}%
  {$A(\allconstants) \land I(\allconstants,\absvariables) \land J(\allconstants,\allvariables) \land
    \concbeforeafter(\allconstants,\concparameters,\concvariables,\concvariables') \limp
    W(\allconstants,\allvariables,\allparameters,x)$}
A witness $W(\allconstants,\allvariables,\allparameters,x)$ may contain well-definedness conditions.
\pode{Well-definedness of a witness}{\eventbpo{eventlabel/witnesslabel/WWD}}%
  {TODO}

\paragraph{Initialization}
\index{initialization}
The initialization of a machine is given by a special event, called \textsl{INITIALISATION}.
Unlike in other events, the initialization must not contain guards and parameters.
The actions must not make use of variable values before the initialization event occurs.
All variables must be assigned a value to. If there is no assignment for the variable $x$,
Rodin assumes a default assignment of the form $x\bcmsuch \btrue$.

\paragraph{Ensuring machine consistency}
\label{consistency_proof_obligations}
The following proof obligations are generated for events:

The assignment $a$ of each action with label $\eventbpo{actionlabel}$ of an event must be well-defined.
  \pode{Well-definedness of actions}%
  {\eventbpo{eventlabel/actionlabel/WD}}%
  {$A(\allconstants) \land I(\allconstants,\allvariables) \land G(\allconstants,\concvariables,\concparameters) \limp %
    \wdl(~a~)$}
  

If the event's guard is enabled, every action must be feasible.
  This trivially true in the case of the deterministic assignments.
  For a non-deterministic assignment $a$, the feasibility $\actfis(a)$ must be proven.
  The feasibility operator $\actfis$ is defined in the reference
  secion of the non-deterministic assignments.
  
  \pode{Action feasibility}{\eventbpo{eventlabel/actionlabel/FIS}}%
  {$A(\allconstants) \land I(\allconstants,\allvariables) \land G(\allconstants,\concvariables,\concparameters) \limp \actfis(a)$}

For each invariant $I_i$ with label \eventbpo{invlabel} 
  that contains a variable that is affected by the assignment, it must be proven
  that the invariant still holds with the new values.
  \pode{Invariant preservation}%
  {\eventbpo{eventlabel/invlabel/INV}}%
  {$A(\allconstants) \land I(\allconstants,\allvariables) \land G(\allconstants,\concvariables) \limp I_i(\allconstants,\allvariables')$}
  Rodin simplifies this proof obligations by replacing $x'$ by $x$ for variables that are not
  changed and $x'$ by $E(\allconstants,\concvariables,\concparameters)$ 
  for variables that are assigned by an deterministic ($x \bcmeq E$) assignment.

For the initializations we have the following special cases:
  \pode{Action feasibility (in the initialization)}{\eventbpo{INITIALISATION/actionlabel/FIS}}%
  {$A(\allconstants) \limp  \actfis(a)$}
  \pode{Invariant establishment}%
  {\eventbpo{INITIALISATION/invlabel/INV}}%
  {$A(\allconstants) \limp I_i(\allconstants,\allvariables')$}

\subsubsection{Ensuring a correct refinement}
\label{refinement_proof_obligations}
An event can refine one or more events of the abstract machine.
We first consider only the refinement of at most one event. 
For refining more than one event -- called merging events --, please see below in section~\ref{merging_events}.


A concrete event must only be enabled if the abstract event is enabled.
This condition is called \emph{guard strengthening}.


\subsubsection{Merging events}
\label{merging_events}
(This section will be written in a later iteration.)

\subsubsection{Extending events}
\index{superposition refinement}
\label{extending_events}
(This section will be written in a later iteration.)
``Superposition'' should be mentioned here.


\subsubsection{Termination}
\label{termination}
(This section will be written in a later iteration.)

  
\subsection{Generated proof obligations}

We give a brief overview about what POs are generated where. This should help the user to identify the reason of a PO when he just know its label.

\marginpar{CONTENT MIGRATED FROM WIKI!}

Proof obligations (abbreviated as PO) are generated by the proof obligation generator and have the form of Sequents. 

The following tables list the different PO and their associated name.

Next is a table describing the names of context proof obligations: 

\begin{center}
    \begin{tabular}{| p{6cm} | p{3cm} | p{5cm} |}
    \hline
	Well-definedness of an Axiom & $m$ / WD & $m$ is the axiom name\\ \hline
	Well-definedness of a Derived Axiom & $m$  / WD & $m$ is the axiom name \\ \hline
	Derived Axiom & $m$  / THM & $m$ is the axiom name \\ \hline
    \end{tabular}
\end{center}

Next is a table showing the name of machine proof obligations:

\begin{center}
    \begin{tabular}{| p{6cm} | p{3cm} | p{5cm} |}
    \hline
	Well-definedness of an Invariant & $v$  / WD & $v$ is the invariant name\\ \hline
	Well-definedness of a Derived Invariant & $m$  / WD & $m$ is the invariant name \\ \hline
	Well-definedness of an event Guard & $t$  / $d$  / WD & $t$ is the event name, $d$ is the action name  \\ \hline
	Well-definedness of an event Action & $t$  / $d$  / WD & $t$ is the event name, $d$ is the action name  \\ \hline
	Feasibility of a non-det. event Action & $t$  / $d$  / FIS & $t$ is the event name, $d$ is the action name  \\ \hline
	Derived Invariant & $m$ / THM & $m$ is the invariant name \\ \hline
	Invariant Establishment & INIT.  / $v$  / INV & $v$ is the invariant name  \\ \hline
	Invariant Preservation & $t$  / $v$  / INV & $t$ is the event name, $v$ is the invariant name  \\ \hline
    \end{tabular}
\end{center}

Next are the proof obligations concerned with machine refinements:

\begin{center}
    \begin{tabular}{| p{6cm} | p{3cm} | p{5cm} |}
    \hline
	Guard Strengthening & $t$  / $d$  / GRD & $t$ is the concrete event name, $d$ is the abstract guard name\\ \hline
	Guard Strengthening (merge) & $t$  / MRG & $t$ is the concrete event name \\ \hline
	Action Simulation & $t$  / $d$  / SIM & $t$ is the concrete event name, $d$ is the abstract action name  \\ \hline
	Equality of a preserved Variable & $t$  / $v$  / EQL & $t$ is the concrete event name, $v$ is the preserved variable  \\ \hline
    \end{tabular}
\end{center}

Next are the proof obligations concerned with the new events variant:

\begin{center}
    \begin{tabular}{| p{6cm} | p{3cm} | p{5cm} |}
    \hline
	Well definedness of Variant & VWD & \\ \hline
	Finiteness for a set Variant & FIN &  \\ \hline
	Natural number for a numeric Variant & $t$  / NAT & $t$ is the new event name \\ \hline
	Decreasing of Variant & $t$  / VAR & $t$ is the new event name  \\ \hline
    \end{tabular}
\end{center}

Finally, here are the proof obligations concerned with witnesses:

\begin{center}
    \begin{tabular}{| p{6cm} | p{3cm} | p{5cm} |}
    \hline
	Well definedness of Witness & $t$  / $p$  / WWD & $t$ is the concrete event name, $p$ is parameter name, or a primed variable name \\ \hline
	Feasibility of non-det. Witness & $t$  / $p$  / WFIS & $t$ is the concrete event name, $p$ is parameter name, or a primed variable name \\ \hline
    \end{tabular}
\end{center}

Remark: At the moment, the deadlock freeness proof obligation generation is missing. If you need it, you can generate it yourself as a derived invariant saying the the disjunction of the abstract guards imply the disjunction of the concrete guards.

\subsection{Visibility of identifiers}
\label{visibility_of_identifiers}

This table shows which identifiers can be used in predicates or expressions. 
\begin{description}
\item[Sets] Set that are defined in the context (in case of an axiom) or in a seen context.
  If a context extends another context, the sets of the extended context are treated as if they
  are defined in the extending context.
\item[Constants] Like the sets, a constant that is defined in the context (in case of an axiom) or
  in a seen context.
\item[Concrete Variables] Variables that are defined in the machine itself. This does \emph{not}
  include variables of refined machines.
\item[Abstract Variables] Variables that are defined in an abstract machine.
\item[Concrete Parameters] Parameters that are defined in the event itself. This does \emph{not}
  include parameters of refined events.
\item[Abstract Parameters] Parameters that are defined in an abstract event.
\end{description}

\begin{center}
  \newcommand{\markcell}{$\times$}
  \begin{tabular}{lcccccc}
  \hline
            &           &           & concrete  & abstract  & concrete   & abstract \\
            & sets      & constants & variables & variables & parameters & parameters \\
  \hline
  axiom     & \markcell & \markcell &           &           &            & \\
  invariant & \markcell & \markcell & \markcell & \markcell &            & \\
  variant   & \markcell & \markcell & \markcell & \markcell &            & \\
  guard     & \markcell & \markcell & \markcell & \markcell & \markcell  & \\
  witness$^{*}$   & \markcell & \markcell & \markcell & \markcell & \markcell  & \markcell \\
  action$^{*}$    & \markcell & \markcell & \markcell & \markcell & \markcell  &  \\
  \hline
  \end{tabular}    
\end{center}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "rodin-doc"
%%% End: 
