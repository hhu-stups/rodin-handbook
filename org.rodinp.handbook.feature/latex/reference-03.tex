\section{Mathematical Notation}
\label{reference_03}

\paragraph{Note about the current state of the documentation}
Some laws (like the commutative law of addition in arithmetic) would be nice but will not be part of the first iteration of the documentation. E.g. the Z reference manual does this.
References to related proof rules would be nice to have, too. But again, this is not part of the first iteration.

\subsection{Introduction}

\subsubsection{Structure of the reference}
The following reference sections follow the form: \\[2em]
\begin{rrnames}
  math. Symbol  & \texttt{ASCII representation}  & Name of the operator \\
  \ldots & \ldots & \ldots \\
\end{rrnames}
\begin{rodinrefentry}
  \rrdesc A short description of what the operator does
  \rrdef A more formal definition
  \rrtypes A description of the types of all arguments and -- if the operation
    is an expression -- the expression's type.
  \rrwd
    A description of the well-definedness conditions using the $\wdl$ operator.
\end{rodinrefentry}

\subsubsection{Data types}
\label{data_types}

In Event-B we have 3 kinds of basic data types:
\begin{itemize}
\item $\intg$ is the set of all integers.
\item $\Bool$ is the set of Booleans. 
  It has two elements $\Bool = \{\True,\False\}$.
\item User defined carrier sets. 
  These are defined in the \eventbsection{Sets} section of a context.
  There is no assumption made about carrier sets unless it is stated explicitly as
  an axiom.
\end{itemize}
From all data types $\alpha, \beta$ can two other kinds of data types be constructed:
\begin{itemize}
\item $\pow(\alpha)$ contains the sets of elements of $\alpha$.
\item $\alpha\cprod\beta$ contains the pairs where the first element is of type $\alpha$ and the
  second element of type $\beta$.
\end{itemize}
\paragraph{A note about the notation}
We use the Greek letters $\alpha$, $\beta$, $\gamma$ to represent arbitrary data types.
For an expression $E$, we write $E\in\alpha$ to state that $E$ is of type $\alpha$.
In the following descriptions of Event-B's mathematical construct we describe the
  types of all constructs and it components.

E.g., we describe the type of the maplet $E\mapsto F$ with $E\mapsto F\in\alpha\cprod\beta$ with
 $E\in\alpha$ and $F\in\beta$. We do not make any restrictions on the types $\alpha$ and $\beta$.

For predicates, we just describe the data types of its components. 
The predicate itself does not have a type.
E.g. the components' types of the equality of two expressions $E=F$: $E\in\alpha$ and $F\in\alpha$.
By stating that $E$ and $F$ are both of type $\alpha$, we express that both expressions must have the
  same type, but do not make any further assumptions about their types.

\subsubsection{Well-definedness}
\label{well_definedness}
\index{well definedness}

A well definedness condition of an expression or predicate in Event-B is a predicate which describes the condition 
  under which it can be safely evaluated.
The integer division is a prominent example: The expression $x\div y$ makes only sense when $y\neq 0$.

In Rodin, the $\wdl$ operator (TODO: look up how this is called correctly and add a reference to the appropriate
sources) is implemented. Applied to the example above: $\wdl(x\div y) \defi y\neq 0$.

Well-definedness conditions are usually used in the well-definedness proof obligations.

In the following sections, we state for each mathematical construct what the well-definedness conditions are.
In many cases, this is just the conjunction of the well-definedness conditions of the syntactical parts of a 
construct. 

See section~\ref{welldefinedness_of_assignments} for well-definedness conditions of assignments.

\subsection{Predicates}

\subsubsection{Logical primitives}
\index{true!as predicate@as predicate $\btrue$}\index{false!as predicate@as predicate $\bfalse$}
\begin{rrnames}
  $\btrue$  & \texttt{true}  & True \\
  $\bfalse$ & \texttt{false} & False \\
\end{rrnames}
\begin{rodinrefentry}
  \rrdesc
  $\btrue$ resp. $\bfalse$ is the predicate that is always true resp. false.
  \rrwd
  $\wdl(\btrue) \defi \btrue$ \\
  $\wdl(\bfalse) \defi \btrue$ \\
\end{rodinrefentry}

\subsubsection{Logical operators}
\index{conjunction}\index{disjunction}\index{implication}\index{equivalence}\index{negation}
\begin{rrnames}
  $\land$  & \texttt{\&}  & Conjunction \\
  $\lor$   & \texttt{or}  & Disjunction \\
  $\limp$  & \texttt{=>}  & Implication \\
  $\leqv$  & \texttt{<=>} & Equivalence \\
  $\lnot$  & \texttt{not} & Negation \\
\end{rrnames}
\begin{rodinrefentry}
  \rrdesc
  These are the usual logical operators.
  \rrdef
  The following truth tables give an overview:
  \begin{center}
    \begin{tabular}{cc|cccc}
      $P$       & $Q$       & $P\land Q$ & $P\lor Q$ & $P\limp Q$ & $P\leqv Q$ \\
      \hline
      $\bfalse$ & $\bfalse$ & $\bfalse$  & $\bfalse$ & $\btrue$   & $\btrue$   \\
      $\bfalse$ & $\btrue$  & $\bfalse$  & $\btrue$  & $\btrue$   & $\bfalse$  \\
      $\btrue$  & $\bfalse$ & $\bfalse$  & $\btrue$  & $\bfalse$  & $\bfalse$  \\
      $\btrue$  & $\btrue$  & $\btrue$   & $\btrue$  & $\btrue$   & $\btrue$   \\
    \end{tabular}
    \quad
    \begin{tabular}{c|c}
      $P$       & $\lnot P$ \\
      \hline
      $\bfalse$ & $\btrue$ \\
      $\btrue$  & $\bfalse$ \\
    \end{tabular}
  \end{center}
  \rrtypes
    All arguments are predicates.
  \rrwd
    Please note that whereas operators like $\land$ and $\lor$ are principally commutative,
    their well-definedness conditions are not. Thus if their arguments have well-definedness
    conditions, the order matters. E.g. $x\neq 0 \land y\div x=3$ is always well-defined,
    but $y\div x=3 \land x\neq 0$ has still the well-definedness condition $x\neq 0$.

    $\wdl(P\land Q) \defi \ldots$ \\
    $\wdl(P\lor Q) \defi \ldots$ \\
    $\wdl(P\limp Q) \defi \ldots$ \\
    $\wdl(P\leqv Q) \defi \ldots$ \\
    $\wdl(\lnot(P)) \defi \wdl(P)$ \\
\end{rodinrefentry}

All operators that work with predicates ($\land$, $\lor$, quantifier, \ldots). 

\subsection{Sets and relations}

\subsubsection{Sets of functions}
\index{function}\index{injection}\index{surjection}\index{bijection}
\begin{rrnames}
  $\pfun$  & \texttt{+->}   & Partial functions\\
  $\tfun$  & \texttt{-->}   & Total functions \\
  $\pinj$  & \texttt{>+>}   & Partial injections\\
  $\tinj$  & \texttt{>->}   & Total injections \\
  $\psur$  & \texttt{+->>}  & Partial surjections\\
  $\tsur$  & \texttt{-->>}  & Total surjections \\
  $\tbij$  & \texttt{>->>}  & Bijections \\
\end{rrnames}
\begin{rodinrefentry}
  \rrdesc
  A partial function from $S$ to $T$ is a relation that maps an element of $S$ to at most one element
  of $T$. A function is total if its domain contains all elements of $S$, i.e. it maps every element
  of $S$ to an element of $T$.

  A function is injective (is an injection) if two distinct elements of $S$ are always mapped to distinct
  elements of $T$. An equivalent statement is that the inverse of the function is a also a function.

  A function is surjective (is a surjection) if for every element of $T$ there exists an element in $S$
  that is mapped to it.

  A function is bijective (is a bijection) if it is both injective and surjective.
  \rrdef
  $S \pfun T = \{~ f ~|~ f\in S\rel T \land (\forall e,x,y \qdot e\mapsto x\in f \land e\mapsto y\in f \limp x=y) ~\}$\\
  $S \tfun T = \{~ f ~|~ f\in S\pfun T \land \dom(f) = S ~\}$\\
  $S \pinj T = \{~ f ~|~ f\in S\pfun T \land f^{-1} \in  T\pfun S ~\}$\\
  $S \tinj T = (S\pinj T) \binter (S\tfun T)$\\
  $S \psur T = \{~ f ~|~ f\in S\pfun T \land \ran(f) = T ~\}$\\
  $S \tsur T = (S\psur T) \binter (S\tfun T)$\\
  $S \tbij T = (S\tinj T) \binter (S\tsur T)$\\
  \rrtypes
  With $S\in\pow(\alpha)$, $T\in\pow(\beta)$ and for each operator $\opelipse$ of $\pfun$, $\tfun$, $\pinj$, $\tinj$, $\psur$, $\tsur$, $\tbij$:\\
  $S \opelipse T \in \pow(\pow(\alpha\cprod\beta))$
  \rrwd
  For each operator $\opelipse$ of $\pfun$, $\tfun$, $\pinj$, $\tinj$, $\psur$, $\tsur$, $\tbij$:\\
  $\wdl(S\opelipse T) \defi \wdl(S) \land \wdl(T)$
\end{rodinrefentry}


\subsection{Arithmetic}

\subsubsection{Sets of numbers}
\begin{rrnames}
  $\intg$  & \texttt{INT}  & Integers \\
  $\nat$   & \texttt{NAT}  & Natural numbers, starting with 0 \\
  $\nat_1$ & \texttt{NAT1} & Natural numbers, starting with 1 \\
  $\upto$  & \texttt{..}   & Range of numbers
\end{rrnames}
\begin{rodinrefentry}
  \rrdesc
  The set of all integers is denoted by $\intg$. It contains all elements of the type.
  The two subsets $\nat$ and $\nat_1$ contain all elements greater or equal to 0 resp. 1.
  The range of numbers between $a$ and $b$ is denoted by $a \upto b$.
  \rrdef
  $\nat   = \{~ n ~|~ n\in\intg\land n\geq 0~\}$\\
  $\nat_1 = \{~ n ~|~ n\in\intg\land n\geq 1~\}$\\
  $a\upto b = \{~ n ~|~ n\in\intg\land a\leq n \land n\leq b~\}$
  \rrtypes
  $\intg\in\pow(\intg)$ \\
  $\nat\in \pow(\intg)$ \\
  $\nat_1\in\pow(\intg)$ \\
  $a \upto b\in\pow(\intg)$  with  $a\in\intg$ and $b\in\intg$
  \rrwd
  $\wdl(\intg) \defi \btrue$\\
  $\wdl(\nat) \defi \btrue$\\
  $\wdl(\nat_1) \defi \btrue$\\
  $\wdl(a \upto b) \defi \wdl(a) \land \wdl(b)$
\end{rodinrefentry}

\subsubsection{Arithmetic operations}
\begin{rrnames}
  $+$      & \texttt{+}   & Addition \\
  $-$      & \texttt{-}   & Subtraction or unary minus \\
  $\cdot$  & \texttt{*}   & Multiplication \\
  $\div$   & \texttt{/}   & Integer division \\
  $\bmod$  & \texttt{mod} & Modulo \\
\end{rrnames}
\begin{rodinrefentry}
  \rrdesc
  These are the usual arithmetic operations.
  \rrdef
    Addition, subtraction and multiplication behave as expected.

    The division is defined in a way that $1\div 2=0$ and $-1\div 2=0$:\\
    $a\div b = \max(\{~c ~|~ c\in\nat \land b\cdot c \leq a~\})$ for $a\in\nat$ and $b\in\nat$\\
%    $a\div b=c \defi \exists r \qdot 0\leq r \land r<b \land  b\cdot c + r = a$ for $a\in\nat$ and $b\in\nat$\\
    $(-a)\div b = - (a\div b)$\\
    $a\div (-b) = - (a\div b)$
    TODO: Take the definition from Matthias' paper.

    TODO: The same for modulo.
  \rrtypes
  With $a\in\intg$, $b\in\intg$ and for each operator $\opelipse$ of $+$, $-$, $\cdot$, $\div$, $\bmod$: \\
  $a\opelipse b\in\intg$\\
  $-a\in\intg$
  \rrwd
  $\wdl(a+b) \defi \wdl(a) \land \wdl(b)$ \\
  $\wdl(a-b) \defi \wdl(a) \land \wdl(b)$ \\
  $\wdl(-a) \defi \wdl(a)$ \\
  $\wdl(a\cdot b) \defi \wdl(a) \land \wdl(b)$ \\
  $\wdl(a\div b) \defi \wdl(a) \land \wdl(b) \land b\neq 0$ \\
  $\wdl(a\bmod b) \defi \wdl(a) \land \wdl(b) \land a\leq 0 \land b\neq 0$ \\
  TODO: Notation? $\wdl$ is actually implemented in Rodin. Is $\wdd$ still interesting?
  Or should we use something like the domain condition $\mathcal{DOM}$
  because it's simpler for operators?\\
\end{rodinrefentry}

\subsection{ASCII Representations of the Mathematical Symbols}
\label{ascii_representations_of_the_mathematical_symbols}

\marginpar{CONTENT MIGRATED FROM WIKI!}

The mathematical symbols used in the Event-B mathematical language are Unicode characters, beyond the ASCII subset. These characters are not always easy to input with a regular keyboard. To help users enter these characters, a list of standard input strings have been defined. When any of these strings is entered, it is automatically converted by the user interface to the corresponding Unicode character (i.e., mathematical symbol).

\subsubsection{Atomic Symbols}

\begin{center}
    \begin{tabular}{ | l | l | l | p{5cm} |}
    \hline
	ASCII & Symbol \\ \hline
	true & $\top$ \\ \hline
	false & $\bot$ \\ \hline
	INT & $\mathbb{Z}$ \\ \hline
	NAT & $\mathbb{N}$ \\ \hline
	NAT1 & $\mathbb{N_1}$ \\ \hline
    \end{tabular}
    \begin{tabular}{ | l | l | l | p{5cm} |}
    \hline
	ASCII & Symbol \\ \hline
	BOOL & $\mathrm{BOOL}$ \\ \hline
	TRUE & $\mathrm{TRUE}$ \\ \hline
	FALSE & $\mathrm{FALSE}$ \\ \hline
	\{\} & $\emptyset$ \\ \hline
    \end{tabular}
    \begin{tabular}{ | l | l | l | p{5cm} |}
    \hline
	ASCII & Symbol \\ \hline
	prj1 & $\prjone$ \\ \hline
	prj2 & $\prjtwo$ \\ \hline
	id & $\id$ \\ \hline
    \end{tabular}
\end{center}

\subsubsection{Unary Operators}

\begin{center}
    \begin{tabular}{ | l | l | l | p{5cm} |}
    \hline
	ASCII & Symbol \\ \hline
	not & $\neg$ \\ \hline
	finite & $finite$ \\ \hline
	card & $\card$ \\ \hline
	POW & $\pow$ \\ \hline
	POW1 & $\pown$ \\ \hline
    \end{tabular}
    \begin{tabular}{ | l | l | l | p{5cm} |}
    \hline
	ASCII & Symbol \\ \hline
	union & $\union$ \\ \hline
	inter & $\inter$ \\ \hline
	dom & $\dom$ \\ \hline
	ran & $\ran$ \\ \hline
%TODO: TILDE!
    \end{tabular}
    \begin{tabular}{ | l | l | l | p{5cm} |}
    \hline
	ASCII & Symbol \\ \hline
	min & $\min$ \\ \hline
	max & $\max$ \\ \hline
	- & $-$ \\ \hline
    \end{tabular}
\end{center}

\subsubsection{Assignment Operators}

\begin{center}
    \begin{tabular}{ | l | l | l | p{5cm} |}
    \hline
	ASCII & Symbol \\ \hline
	:= & $\bcmeq$ \\ \hline
	:| & $\bcmsuch$ \\ \hline
	:: & $\bcmin$ \\ \hline
    \end{tabular}
\end{center}

\subsubsection{Binary Operators}

\begin{center}
    \begin{tabular}{ | l | l | l | p{5cm} |}
    \hline
	ASCII & Symbol \\ \hline
	\& & $\land$ \\ \hline
	or & $\lor$ \\ \hline
	$=>$ & $\limp$ \\ \hline
	$<=>$ & $\leqv$ \\ \hline
	= & $=$ \\ \hline
	/= & $\neq$ \\ \hline
	: & $\in$ \\ \hline
	$<<:$ & $\subset$ \\ \hline
	$/<<:$ & $\not\subset$ \\ \hline
	$<:$ & $\subseteq$ \\ \hline
	$/<$: & $\not\subseteq$ \\ \hline
	$<$ & $<$ \\ \hline
	$<=$ & $\leq$ \\ \hline
	$>$ & $>$ \\ \hline
	$>=$ & $\geq$ \\ \hline
	/: & $\notin$ \\ \hline
    \end{tabular}
    \begin{tabular}{ | l | l | l | p{5cm} |}
    \hline
	ASCII & Symbol \\ \hline
	$|->$ & $\mapsto$ \\ \hline
	$<->$ & $\rel$ \\ \hline
	$<<->$ & $\trel$ \\ \hline
	$<->>$ & $\srel$ \\ \hline
	$<<->>$ & $\strel$ \\ \hline
	$+->$ & $\pfun$ \\ \hline
	$-->$ & $\tfun$ \\ \hline
	$+>>$ & $\psur$ \\ \hline
	$->>$ & $\tsur$ \\ \hline
	$>->>$ & $\tbij$ \\ \hline
	$/\backslash$ & $\binter$ \\ \hline
	$\backslash/$ & $\bunion$ \\ \hline
	$\backslash$ & $\setminus$ \\ \hline
	$**$ & $\cprod$ \\ \hline
	$>->$ & $\tinj$ \\ \hline
	$>+>$ & $\pinj$ \\ \hline
    \end{tabular}
    \begin{tabular}{ | l | l | l | p{5cm} |}
    \hline
	ASCII & Symbol \\ \hline
	$<+$ & $\ovl$ \\ \hline
	$||$ & $\pprod$ \\ \hline
	$><$ & $\dprod$ \\ \hline
	$circ$ & $\bcomp$ \\ \hline
	$;$ & $\fcomp$ \\ \hline
	$<|$ & $\domres$ \\ \hline
	$<<|$ & $\domsub$ \\ \hline
	$|>$ & $\ranres$ \\ \hline
	$-$ & $-$ \\ \hline
	$*$ & $*$ \\ \hline
	$/$ & $\div$ \\ \hline
	$..$ & $\upto$ \\ \hline
	$TODO$ & $\expn$ \\ \hline
	$+$ & $+$ \\ \hline
	$|>>$ & $\ransub$ \\ \hline
    \end{tabular}
    \begin{tabular}{ | l | l | l | p{5cm} |}
    \hline
	ASCII & Symbol \\ \hline
	$mod$ & $mod$ \\ \hline
    \end{tabular}
\end{center}

\subsubsection{Multiple Operators}

\begin{center}
    \begin{tabular}{ | l | l | l | p{5cm} |}
    \hline
	ASCII & Symbol \\ \hline
	partition & $partition$ \\ \hline
    \end{tabular}
\end{center}

\subsubsection{Quantifiers}

\begin{center}
    \begin{tabular}{ | l | l | l | p{5cm} |}
    \hline
	ASCII & Symbol \\ \hline
	! & $\forall$ \\ \hline
	\# & $\exists$ \\ \hline
	\% & $\lambda$ \\ \hline
	UNION & $\Union$ \\ \hline
	INTER & $\Inter$ \\ \hline
	| & $|$ \\ \hline
	. & $\qdot$ \\ \hline
    \end{tabular}
\end{center}

\subsubsection{Bracketing}

\begin{center}
    \begin{tabular}{ | l | l | l | p{5cm} |}
    \hline
	ASCII & Symbol \\ \hline
	oftype & $\forall$ \\ \hline
	\# & $\exists$ \\ \hline
	\% & $\lambda$ \\ \hline
	UNION & $\Union$ \\ \hline
	INTER & $\Inter$ \\ \hline
	| & $|$ \\ \hline
	. & $\qdot$ \\ \hline
    \end{tabular}
\end{center}

\begin{center}
    \begin{tabular}{ | l | l | l | p{5cm} |}
    \hline
	ASCII & Symbol \\ \hline
	( & $($ \\ \hline
	) & $)$ \\ \hline
	[ & $[$ \\ \hline
	] & $]$ \\ \hline
	\{ & $\{$ \\ \hline
	\} & $\}$ \\ \hline
    \end{tabular}
\end{center}

\subsubsection{Typing}

\begin{center}
    \begin{tabular}{ | l | l | l | p{5cm} |}
    \hline
	ASCII & Symbol \\ \hline
	oftype & \includegraphics[]{img/reference/ref_03_offtype_symbol.png} \\ \hline
    \end{tabular}
\end{center}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "rodin-doc"
%%% End: 
