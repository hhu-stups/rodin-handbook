\section{Proving}
\label{reference_04}

In Section~\ref{ref:generated_proof_obligations}, we learned what proof obligations are generated by Rodin from an Event-B model.  We validate the model by discharging proof obligations.  This is what we call proving.

\tick{In this chapter we will:
\begin{itemize}
	\item Explain proof rules
	\item Explain tactics
	\item Explain and describe provers
	\item Explain reasoners
	\item Describe how to perform automatic and manual proving
\end{itemize}}

\subsection{Proof Rules}
\index{proof rule}

In its pure mathematical form, a proof rule is a tool to perform formal proof and is denoted by: 

$$\frac{\quad A\quad}{C}$$

where A is a (possibly empty) list of sequents (the antecedents of the proof rule), and C is a sequent (the consequent of the rule). We interpret the above proof rule as follows: The combination of the proofs of each sequent of A prove the sequent C. 

\pencil{\textbf{Example:} Consider the following proof rule:
$$ \frac{ E_1 }{ E_1 \lor E_2 } $$
This says that if $E_1$ holds, then $E_1 \lor E_2$ holds as well.  Thus, we can replace the sequent by the consequent.
}

\subsubsection{Proof Rule Representation in Rodin}

In Rodin, the representation for proof rules is more structured not only to reduce the space required to store the rule but more importantly to support proof reuse.
A proof rule in Rodin contains the following:

\begin{description}
	\item[used goal] A used goal predicate. 
	\item[used hypotheses] The set of used hypotheses. 
	\item[antecedents] A list of antecedents (to be explain later). 
	\item[reasoner] The reasoner used to generate this proof rule (see reasoners (\ref{ref:reasoners})). 
	\item[reasoner input] The input for the reasoner to generate this proof rule (see reasoners (\ref{ref:reasoners}). 
\end{description}

Each antecedent of the proof rule contains the following information:

\begin{description}
	\item[new goal] A new goal predicate. 
	\item[added hypotheses] The set of added hypotheses. 
\end{description}

With this representation, a proof rule in Rodin corresponding to a proof schema as follows: 

$$\begin{array}{c} H, H_u, H_{A_0} \vdash G_{A_0} ~~~\ldots~~~ H, H_u, H_{A_n-1} \vdash G_{A_n-1} \\ \hline H, H_u \vdash G_u \end{array} $$

Where:
\begin{itemize}
	\item     $H_u$ is the set of used hypotheses 
	\item     $G_u$ is the used goal 
	\item     $H_{A_i}$ is the set of added hypotheses corresponding to the ith antecedent. 
	\item     $G_{A_i}$ is the new goal corresponding to the ith antecedent. 
	\item     $H$ is the meta-variable that can be instantiated. 
\end{itemize}

\subsubsection{Applying Proof Rules}

Given a proof rule of the form mentioned above, the following describes how to apply this rule to an input sequent. The result of this process is a list of output sequents if the process is successful or none if not.

\begin{itemize}
	\item The rule is applicable if the goal of the sequent is not exactly the same as the used goal or if any of the used hypotheses are not contained in the set of hypotheses of the input sequent. 
	\item If the case is applicable, the antecedent sequents are returned. The goal of each antecedent sequent is the new goal. The hypotheses of each antecedent sequent are the union of the old hypotheses and added hypotheses of the corresponding antecedent. 
\end{itemize}

\info{The user interface for proving is explained in Section~\ref{ref_01_proving_perspective}.  The practical application of proof rules is explained in Section~\ref{tut:first_proof}}.

\subsection{Proof Tactics}
\index{Proof Tactics}
\index{Tactics}

Tactics provide an easier way to construct and manage proof search and manipulation. They provide calls to the underlying reasoners or other tactics to modify proofs.

\info{A list of all proof tactics is maintained in the Rodin Wiki\footnote{\url{http://wiki.event-b.org/index.php/Rodin_Proof_Tactics}}}.  This list is really comprehensive --- be sure to check it out!

Tactics can be applied as follows:

\begin{description}
	\item[Automatic] Rodin can try a number of tactics after each manual proof step (In the GUI: Section~\ref{}).
	\item[Proof tree] Pruning the proof tree is one (drastic) tactic that is applied from the proof tree through the context menu.  Other tactics may be available there.
	\item[In sequents] Some sequents have elements that are highlighted in red.  clicking on those exposes a menu with all applicable tactics, where they can be applied manually.
\end{description}

It can be useful to consider the following categorization of tactics:

\subsubsection{Basic Tactics}

They are those tactics that make change to the proof tree only at the point of application.

\begin{itemize}
	\item     Prune A direct application of the pruning facility providing by the proof tree. The tactic is successful if the input node are non-pending. 
	\item     Rule Application Tactics of this class provide a wrapper around a proof rule (See Proof Rules). The tactic is successful if the proof rule is successful applied to the input node. 

	\item     Reasoner Application Tactics of this class provide a wrapper around a reasoner (See Reasoner). The tactic is successful if the reasoner is successful applied to the input node. 
\end{itemize}

\subsubsection{Tactical Tactics}

They are those tactics that are constructed from existing tactics. They indicate different strategic or heuristic decisions.

\begin{itemize}
	\item         Apply on All Pending Apply a specific sub-tactic to all pending nodes of the point of application. The tactic is successful if the sub-tactic is successful on one of the pending nodes. 
	\item         Repeating Repeating a specific sub-tactic to the point of application until it fails. The tactic is successful if the sub-tactic is successful at least once. 
	\item         Composing Sequential compose a list of sub-tactics to apply to the point of application. The tactic is successful if one of the sub-tactic is successful. 
\end{itemize}

More complex proof strategy can be constructed by composing the above tactical tactics. 

\subsection{Provers}
\index{Atelier B provers}

In the end, provers perform the actual work.  Rodin comes with one prover installed (NewPP).  It is strongly recommended to install the third-party provers from Atelier B provers (as described in Section~\ref{}), adding the PP and ML provers.  More provers may be available as plugins.

We will now give a very brief overview over the existing provers, pointing out their strengths/weaknesses.

\subsubsection{PP}

PP is recommended as the prover to try first, as it is sound and generally pretty good.

\begin{description}
	\item[Names in the proof control:]  P0, P1, PP
	\item[Names in the proof tree:] PP
	\item[Names in the preferences:] Atelier B P0, Atelier B P1, Atelier B PP
	\item[Input:] In the configuration "P0" all selected hypotheses and the goal are passed to PP. In the configuration "P1" one lasso operation is applied to the selected hypotheses and the goal and the result is passed to PP. In the configuration "PP" all the available hypotheses are passed to PP.
	\item[How the Prover Proceeds:] The input sequent is translated to classical B and fed to the PP prover of Atelier B. PP works in a manner similar to newPP, but with support for equational and arithmetic reasoning.
	\item[Some Strengths:] ~
	\begin{itemize}
		\item PP has limited support for equational and arithmetic reasoning. 
	\end{itemize}
	\item[Some Weaknesses:] ~
\begin{itemize}
	\item PP does not output a set of used hypotheses.
	\item PP is unaware of some set theoretical axioms.
	\item PP has similar problems concerning well-definedness as New PP.
	\item If unnecessary hypotheses are present, they may prevent PP from finding a proof, even when the proof obligation obviously holds. 
\end{itemize}
\end{description}

\subsubsection{ML}

The ML prover can be quite helpful when the proofs involve arithmetic.

\begin{description}
	\item[Names in the proof control:] M0, M1, M2, M3, ML
	\item[Names in the proof tree:] ML
	\item[Names in the preferences:] Atelier B ML
	\item[Input:] All visible hypotheses are passed to ML. The different configurations refer to the configuration (proof force) of the ML prover.
	\item[How the Prover Proceeds:] ML applies a mix of forward, backward and rewriting rules in order to discharge the goal (or detect a contradiction among hypotheses).
	\item[Some Strengths:] ~
	\begin{itemize}
		\item ML has limited support for equational and arithmetic reasoning.
		\item ML is more resilient to unnecessary hypotheses than newPP and PP. 
	\end{itemize}
	\item[Some Weaknesses:] ~
	\begin{itemize}
		\item ML does not output a set of used hypotheses.
		\item Not all set theoretical axioms are part of ML. 
	\end{itemize}
\end{description}


\subsubsection{New PP}
\warning{New PP is unsound. There have been several bug reports. Some have been fixed, but at this point We do not recommend New PP for inexperienced users.}

\begin{description}
	\item[Names in the proof control:] nPP R., nPP with a lasso symbol, nPP
	\item[Names in the proof tree:] Predicate Prover
	\item[Names in the preferences:] PP restricted, PP after lasso, PP unrestricted
	\item[Input:] In the configuration "restricted" all selected hypotheses and the goal are passed to New PP. In the configuration "after lasso" a lasso operation is applied to the selected hypotheses and the goal and the result is passed to New PP. The lasso operation selects any unselected hypothesis that has a common symbol with the goal or a hypothesis that was selected before. In the configuration "unrestricted" all the available hypotheses are passed to New PP.
	\item[How the Prover Proceeds:] First, all function and predicate symbols that are different from "$\in$" and not related to arithmetic are translated away. For example A $\subseteq B$ is translated to $\forall x\cdot x \in A \limp x \in B$. Then New PP translates the proof obligation to CNF (conjunctive normal form) and applies a combination of unit resolution and the Davis Putnam algorithm.
	\item[Some Strengths:] ~
	\begin{itemize}
		\item New PP outputs a set of "used hypotheses". If an unused hypotheses changes, the old proof can be reused.
		\item New PP has limited support for equational reasoning. 
	\end{itemize}
	\item[Some Weaknesses:]
	\begin{itemize} ~
		\item New PP is unsound. There have been several bug reports. Most notably, see [1].
		\item New PP does not support arithmetic; hence, $\vdash_{\mathcal L} 1=1$ is discharged, but $\vdash_{\mathcal L} 1+1=2$ is not. Note that arithmetic 	reasoning (when the formula is not ground) is a long standing challenge.
		\item New PP is unaware of set theoretical axioms; in particular, $\vdash_{\mathcal L} \exists A\cdot \forall x\cdot x \in A \leqv x \in B \lor x \in C$, because the union axiom is not available within New PP. Roughly spoken, New PP can only reuse sets that already appear in the formula, but it is unable to introduce new sets. Note that set theoretical reasoning is perceived as a hard problem.
		\item If unnecessary hypotheses are present, they may prevent New PP from finding a proof, even when the proof obligation obviously holds. We therefore advise to unselect unnecessary hypotheses.
		\item New PP does not take well-definedness into account:
	        Lemma $\vdash_{\mathcal L} b \in f^{-1} [\{f(b)\}]$ is not discharged. In fact, this sequent has exactly the same translation as $\vdash_{\mathcal L} b \in\dom(f)$, which is not provable. 
		\item New PP tends to run out of memory, if the input is large. 
	\end{itemize}
\end{description}

\subsection{How to Use the Provers Effectively}
\label{ref:use_provers_effectively}

It is very hard, in general, to predict whether a certain automatic prover can or cannot discharge a given proof obligation within a given amount of time. (This is also the case for many other automatic first order theorem provers.) Therefore applying the 11 configurations in a trial and error fashion is often frustrating.

The following guidelines may be useful:

\begin{itemize}
	\item Add New PP restricted (PP restricted), P0 (Atelier B P0), and ML (Atelier B ML) to the auto-tactic. If the auto-tactic runs out of memory, remove New PP.
	\item If the model is small, add New PP after lasso (PP after lasso) and P1 (Atelier B P1) to the auto-tactic.
	\item Whenever you think that the current proof obligation should be discharged automatically, invoke the auto-tactic (the green robot) instead of some particular automatic prover.
	\item If the auto-tactic fails, it is usually best to simplify the proof obligation in some way. The most important ways of simplifying the proof obligation are:
	\begin{itemize}
		\item Remove unnecessary hypotheses; add required hypotheses that have been missing.
		\item Do some case splits.
		\item Instantiate quantifiers.
		\item Apply ae (abstract expression) to replace complicated expressions by fresh variables. 
	\end{itemize}
	\item You can also apply one of the automatic provers. They may be more successful than the auto-tactic, because they have a longer timeout.
	\begin{itemize}
		\item Try New PP before PP or ML, because New PP proofs can be better reused, if the model changes.
		\item The configurations that act on more than the selected hypotheses (New PP after lasso and unrestricted, P1 and PP, ML) become useless when the model grows. 
	\end{itemize}
	\item When everything fails, start to unfold the proof obligation manually, by clicking on the red links.
	\begin{itemize}
		\item You may discover that some assumption was missing.
		\item You may complete the proof.
		\item If you observe that a valid proof obligation cannot be proved manually, please send a bug report. (Rodin Bug Tracker) 
	\end{itemize}
\end{itemize}

\subsection{Reasoners}
\label{ref:reasoners}
\index{reasoner}

Reasoners apply on the sequent of a given proof tree node and is a way to contribute to the provers.  They are typically not of direct interest to the user, but to the developer.

A reasoner is (and has to be) quite "rough" : it shall take a given sequent and produce a proof rule that will (if possible) apply on this given sequent, whereas a tactic could be smarter. Indeed, a tactic can involve several reasoners, thus apply them in loops, and combine them, or even call other tactics.

