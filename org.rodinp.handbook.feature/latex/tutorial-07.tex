\section{Expanding the Traffic Light System: Contexts and Refinement}
\label{tutorial_07}

\tick{\textbf{Goals:} We apply what we learned in the previous section by introducing a context with traffic light colors, and a refinement to integrate them. We will introduce another refinement for the push buttons.}

\subsection{Data Refinement}
\label{tutorial:data_refinement}

We will continue the example from Section~\ref{tutorial_03}, where we built a simplified model of a traffic light controller.  The model was simplified because we abstracted the traffic lights to TRUE and FALSE, and a number of features were still missing.

We will introduce data refinement in this section.  The objective is to create a mapping between the abstract traffic light values and actual colors.  The following image depicts our mapping for the traffic light.

\begin{center}
	\includegraphics{img/tutorial/tl-colors.png}
	\label{fig:tl-colors}
\end{center}

For simplicity, the traffic light for pedestrians consists of only two lights, red and green.

We break this problem into two steps:

\begin{enumerate}
	\item Create a context with the data structures for the colors
	\item Create a refinement of the existing model that sees the new context and refines the boolean states into colors.
\end{enumerate}

\subsection{A Context with Colors}

Start by creating a context called \texttt{ctx1}, as described in Section~\ref{tutorial_05}.
We model the colors as constants:

\pencil{
\begin{description}
\CONSTANTS
	\begin{description}
		\Item{ red }
		\Item{ yellow }
		\Item{ green }
	\end{description}
\end{description}
}

These constants are part of a set:

\pencil{
\begin{description}
\SETS
	\begin{description}
		\Item{ COLORS }
	\end{description}
\end{description}
}

And last, we need to provide typing.  We do this by creating a partition (\ref{partition}):

\pencil{
\begin{description}
\AXIOMS
	\begin{description}
		\nItemX{ type }{ partition(COLORS, \{ red\} , \{ yellow\} , \{ green\} ) }
	\end{description}
\end{description}
}

\warning{Please note the curly braces \{\} around the colors.  It's very easy to forget these, which will result in typing errors that are very hard to interpret for a novice.
}

This completes the context.

\subsection{The Actual Data Refinement}

The easiest way to create a refinement is by right-clicking on the machine in the project browser and to select \textsf{Refine}.  This will create a ``stub'' consisting of all variables and events.

TODO: Screenshot of selecting the context menu.

\warning{In refinements, the \textsf{Edit} View of the Editor hides some information from the abstract machine by default.  This can be particularly important when you modify a refined event.  The \textsf{Pretty Print} View shows all element, with elements from the abstract machine in \textit{italics}.}

First we have to make the machine aware of the context by adding a \textsf{sees} (\ref{sees}) statement:

\pencil{
\begin{description}
\MACHINE{mac1}
\REFINES{mac0}
\SEES{ctx1}
\end{description}
}

We start with the traffic lights for the pedestrians, which consists of just two colors (red and green).  We introduce a new variable to represent the traffic light colors called \textsf{peds\_colors}, with corresponding typing and an initialization (only the changes are shown in the following):

\pencil{
\begin{description}
\VARIABLES
	\begin{description}
		\Item{ peds\_colors }
	\end{description}
\INVARIANTS
	\begin{description}
		\nItemX{ inv4 }{ peds\_colors \in  \{  red, green \}  }
	\end{description}
\EVENTS
	\INITIALISATION
		\\\textit{extended}
		\begin{description}
		\BeginAct
			\begin{description}
			\nItemX{ init4 }{ peds\_colors :=  red }
			\end{description}
		\EndAct
		\end{description}
\END
\end{description}
}

Next, we will create a gluing invariant (\ref{gluing_invariant}) that associated \textsf{peds\_go} from the abstract machine with the variable \textsf{peds\_colors} that we just created.  The gluing invariant shall map \textsf{TRUE} to \textsf{green} and \textsf{FALSE} to \textsf{red}:

\pencil{
\begin{description}
\INVARIANTS
	\begin{description}
		\nItemX{ gluing }{ peds\_go = TRUE \leqv  peds\_colors = green }
	\end{description}
\end{description}
}

In its current state, this gluing invariant can be violated: if the event \textsf{set\_peds\_go} is triggered, for instance, the variable \textsf{peds\_go} will change, but not \textsf{peds\_colors}.  We expect that this will result in undischarged proof obligations \ref{undischarged_proof_obligations}.  We can check this by expanding the machine in the Event-B Explorer.  Indeed, we now see two undischarged proof obligations:

\begin{center}
	\includegraphics{img/tutorial/undischarged1.png}
	\label{fig:undischarged}
\end{center}

To fix this, we have to modify the two events in question.  Let's start with \textsf{set\_peds\_go}.  First, we change the event from extended to not extended in the Editor:

\begin{center}
	\includegraphics{img/tutorial/event-refinement.png}
	\label{fig:event-refinement}
\end{center}

This change will copy the guard and action from the abstract machine, so that we can modify it.  We can now replace the action with the corresponding action regarding \textsf{peds\_colors} (setting it to \textsf{go}).  While we are at it, we can also rename the name of the event to something more fitting (e.g. \textsf{set\_peds\_green}).

Next, we perform the corresponding change on \textsf{set\_peds\_stop}.  And last, \textsf{set\_cars} also contains a reference to \textsf{peds\_go} that must be replaced.

Once all references to \textsf{peds\_go} have been replace, we can remove the variable \textsf{peds\_go} from the \textsf{VARIABLES} section.  You shouldn't have any errors or warnings, and all proof obligations should be discharged.

\warning{If you get the error message ``Identifier peds\_go has not been declared'', then there are references to the refined variable left somewhere in the model.  It can be helpful to use the \textsf{Pretty Print} view, as it will show the ``inherited'' elements from the abstract machine as well.}

\subsection{The refined machine with data refinement for peds\_go}

\pencil{
\begin{description}
\MACHINE{mac1}
\REFINES{mac0}
\SEES{ctx1}
\VARIABLES
	\begin{description}
		\Item{ cars\_go }
		\Item{ peds\_colors }
	\end{description}
\INVARIANTS
	\begin{description}
		\nItemX{ inv4 }{ peds\_colors \in  \{  red, green \}  }
		\nItemX{ gluing }{ peds\_go = TRUE \leqv  peds\_colors = green }
	\end{description}
\EVENTS
	\INITIALISATION
		\begin{description}
		\BeginAct
			\begin{description}
			\nItemX{ act1 }{ cars\_go :=  FALSE }
			\nItemX{ init4 }{ peds\_colors :=  red }
			\end{description}
		\EndAct
		\end{description}
	\EVT {set\_peds\_green}
	\REF {set\_peds\_go}
		\begin{description}
		\WhenGrd
			\begin{description}
			\nItemX{ grd1 }{ cars\_go = FALSE }
			\end{description}
		\ThenAct
			\begin{description}
			\nItemX{ act2 }{ peds\_colors :=  green }
			\end{description}
		\EndAct
		\end{description}
	\EVT {set\_peds\_red}
	\REF {set\_peds\_stop}
		\begin{description}
		\BeginAct
			\begin{description}
			\nItemX{ act1 }{ peds\_colors :=  red }
			\end{description}
		\EndAct
		\end{description}
	\EVT {set\_cars}
	\REF {set\_cars}
		\begin{description}
		\AnyPrm
			\begin{description}
			\ItemX{ new\_value }
			\end{description}
		\WhereGrd
			\begin{description}
			\nItemX{ grd1 }{ new\_value \in  BOOL }
			\nItemX{ grd2 }{ new\_value = TRUE \limp  peds\_colors = red }
			\end{description}
		\ThenAct
			\begin{description}
			\nItemX{ act1 }{ cars\_go :=  new\_value }
			\end{description}
		\EndAct
		\end{description}
\END
\end{description}
}

\subsection{Witnesses}

The refinement of \textsf{set\_cars} is more difficult, as the event uses a parameter (the new value for \textsf{cars\_go}).  In order to create the association, we need a witness (\ref{witness}).

A witness is for an event's parameter what a gluing invariant is for a variable: it is a mapping between the abstract parameter and the new parameter and allows the abstract parameter to disappear.  In this example, the abstract parameter \textsf{new\_value} is of type \textsf{BOOL}, while we introduce a new parameter \textsf{new\_value\_colors} of type \textsf{COLORS}.

\warning{The naming of a witnesses' label is mandatory and must be the name of the abstract parameter.  In our example, the label must be \textsf{new\_value}}

So let's get started.  We first provide the new variable, gluing invariant, typing invariant and initialization as before.  Note that the traffic light for the cars can show more than one color at a time.  Therefore, the variable contains a set of colors, instead of just one color (as modelled for \textsc{peds\_colors}):

\pencil{
\begin{description}
\VARIABLES
	\begin{description}
		\Item{ cars\_colors }
	\end{description}
\INVARIANTS
	\begin{description}
		\nItemX{ inv5 }{ cars\_colors \subseteq  COLORS }
		\nItemX{ gluing\_cars }{ cars\_go = TRUE \leqv  green \in  cars\_colors }
	\end{description}
\EVENTS
	\INITIALISATION
		\begin{description}
		\BeginAct
			\begin{description}
			\nItemX{ init5 }{ cars\_colors :=  \{  red \}  }
			\end{description}
		\EndAct
		\end{description}
	\END
\end{description}
}

We also have to modify the guard on \textsf{set\_peds\_green}, something that you should now be able to figure out yourself.

The interesting piece is the last event, \textsf{set\_cars}, which we rename into \textsf{set\_cars\_colors}.  We change the parameter to \textsf{new\_value\_colors} and type it as a subset of \textsf{COLORS}.

The witness appears in the \textsf{with} section of the event.  The label \textbf{must} be \textsf{new\_value}.  The value itself must describe the relationship between the abstract parameter \textsf{new\_value} and the new parameter \textsf{new\_value\_colors}.  As we use the parameter as the new value for the variable \textsf{cars\_colors}, the witness is an adaptation of the gluing invariant (we just replace \textsf{cars\_colors} with \textsf{new\_value\_colors}.

\info{In most cases, the witness is a slightly modified gluing invariant.}

Here is the resulting event:

\pencil{
\begin{description}
	\EVT {set\_cars\_colors}
	\REF {set\_cars}
		\begin{description}
		\AnyPrm
			\begin{description}
			\ItemX{ new\_value\_colors }
			\end{description}
		\WhereGrd
			\begin{description}
			\nItemX{ grd1 }{ new\_value\_colors \subseteq  COLORS }
			\nItemX{ grd2 }{ green \in  new\_value\_colors \limp  peds\_colors = red }
			\end{description}
		\Witnesses
			\begin{description}
			\nItem{ new\_value }{ new\_value = TRUE \leqv  green \in  new\_value\_colors }
			\end{description}
		\ThenAct
			\begin{description}
			\nItemX{ act1 }{ cars\_colors :=  new\_value\_colors }
			\end{description}
		\EndAct
		\end{description}
\end{description}
}

Even though all proof obligations are now discharged, we're not done yet: While the traffic light doesn't violate the safety property from the abstract machine, it doesn't behave the way described in Section~\ref{data_refinement}.  We still have to ensure that the lights are activated in the proper sequence.  We can impose this behavior by adding four guards, with each guard defining one transition:

\pencil{
\begin{description}
\nItemX{ grd\_y\_r }{ cars\_colors = \{  yellow \}  \limp  new\_value\_colors = \{  red \}  }
\nItemX{ grd\_r\_ry }{ cars\_colors = \{  red \}  \limp  new\_value\_colors = \{  red, yellow \}  }
\nItemX{ grd\_ry\_g }{ cars\_colors = \{  red, yellow \}  \limp  new\_value\_colors = \{  green \}  }
\nItemX{ grd\_g\_y }{ cars\_colors = \{  green \}  \limp  new\_value\_colors = \{  yellow \}  }
\end{description}
}

\subsection{Discussion}

Note that we used two very different approaches to model the traffic lights for cars and pedestrians.  For the pedestrians, we created one event for each state transition.  For the cars, we handled all states in one single event.

You will often be confronted with situations where many modelling approaches are possible.  You should consider two main factors when modelling: (1) readability of the model and (2) ease of proof.  In this case, both approaches are equally good (although we wouldn't recommend mixing different approaches in one model.  We did it here only to demonstrate both approaches).

We hope that this Section helped you to understand the power of abstraction.  The safety invariant from Section~\ref{tutorial:invariants} was very simple.  We could now introduce colors, being confident that the invariant will still hold (assuming, of course, that our gluing invariant is correct).

\subsection{The Refined Machine with All Data Refinement}

\pencil{
\begin{description}
\MACHINE{mac1}
\REFINES{mac0}
\SEES{ctx1}
\VARIABLES
	\begin{description}
		\Item{ peds\_colors }
		\Item{ cars\_colors }
	\end{description}
\INVARIANTS
	\begin{description}
		\nItemX{ inv4 }{ peds\_colors \in  \{  red, green \}  }
		\nItemX{ inv5 }{ cars\_colors \subseteq  COLORS }
		\nItemX{ gluing\_peds }{ peds\_go = TRUE \leqv  peds\_colors = green }
		\nItemX{ gluing\_cars }{ cars\_go = TRUE \leqv  green \in  cars\_colors }
	\end{description}
\EVENTS
	\INITIALISATION
		\begin{description}
		\BeginAct
			\begin{description}
			\nItemX{ init4 }{ peds\_colors :=  red }
			\nItemX{ init5 }{ cars\_colors :=  \{  red \}  }
			\end{description}
		\EndAct
		\end{description}
	\EVT {set\_peds\_green}
	\REF {set\_peds\_go}
		\begin{description}
		\WhenGrd
			\begin{description}
			\nItemX{ grd1 }{ green \notin  cars\_colors }
			\end{description}
		\ThenAct
			\begin{description}
			\nItemX{ act2 }{ peds\_colors :=  green }
			\end{description}
		\EndAct
		\end{description}
	\EVT {set\_peds\_red}
	\REF {set\_peds\_stop}
		\begin{description}
		\BeginAct
			\begin{description}
			\nItemX{ act1 }{ peds\_colors :=  red }
			\end{description}
		\EndAct
		\end{description}
	\EVT {set\_cars\_colors}
	\REF {set\_cars}
		\begin{description}
		\AnyPrm
			\begin{description}
			\ItemX{ new\_value\_colors }
			\end{description}
		\WhereGrd
			\begin{description}
			\nItemX{ grd1 }{ new\_value\_colors \subseteq  COLORS }
			\nItemX{ grd2 }{ green \in  new\_value\_colors \limp  peds\_colors = red }
			\nItemX{ grd\_y\_r }{ cars\_colors = \{  yellow \}  \limp  new\_value\_colors = \{  red \}  }
			\nItemX{ grd\_r\_ry }{ cars\_colors = \{  red \}  \limp  new\_value\_colors = \{  red, yellow \}  }
			\nItemX{ grd\_ry\_g }{ cars\_colors = \{  red, yellow \}  \limp  new\_value\_colors = \{  green \}  }
			\nItemX{ grd\_g\_y }{ cars\_colors = \{  green \}  \limp  new\_value\_colors = \{  yellow \}  }
			\end{description}
		\Witnesses
			\begin{description}
			\nItem{ new\_value }{ new\_value = TRUE \leqv  green \in  new\_value\_colors }
			\end{description}
		\ThenAct
			\begin{description}
			\nItemX{ act1 }{ cars\_colors :=  new\_value\_colors }
			\end{description}
		\EndAct
		\end{description}
\END
\end{description}
}

