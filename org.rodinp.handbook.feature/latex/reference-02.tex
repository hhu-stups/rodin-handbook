\newcommand{\varlist}[1]{\mathbf{#1}}
\newcommand{\allconstants}{\varlist{c}}
\newcommand{\absvariables}{\varlist{v}}
\newcommand{\concvariables}{\varlist{w}}
\newcommand{\allvariables}{{\absvariables,\concvariables}}
\newcommand{\absparameters}{\varlist{t}}
\newcommand{\concparameters}{\varlist{u}}
\newcommand{\allparameters}{{\absparameters,\concparameters}}
\newcommand{\absbeforeafter}{\mathcal{S}}
\newcommand{\concbeforeafter}{\mathcal{T}}

\section{Event-B (Modeling notation)}
\label{reference_02}
\label{proof_obligation}

In Event-B, we have two types of components: contexts and machines.
Here we describe briefly the different elements of a context or machine.
We do not use a specific syntax for describing the components because the syntax is dependent on the editor that is
used. The default editor requires a structure which contains the elements that are described here.

Proof obligations are generated to guarantee certain properties of the modeled system.
We will explain here which proof obligations are generated and we will list the goal and hypotheses that can be used
when performing the proof for each one.
This is done in the form:
\podef{Description}{Label of the proof obligation (\eventbpo{label} refers to the label of the respective 
  axiom/invariant/guard/etc.)}{Goal that should be proved}{Hypotheses that can be used}

\subsection{About the notation that we use}
(Variable substitution)

We denote a sequence of identifiers with $\varlist{x} = x_1,\ldots,x_n$ and $\varlist{x}' = x'_1,\ldots,x'_n$
As a convention, we use
\begin{itemize}
\item $\allconstants$ for constants
\item $\absvariables$ and $\concvariables$ for abstract variables and concrete variables
\item $\absparameters$ and $\concparameters$ for abstract and concrete parameters
\end{itemize}

\subsection{Contexts}
\index{context}
A context describes the static part of a model. It consists of
\begin{itemize}
\item Carrier sets
\item Constants
\item Axioms
\item Extended contexts
\end{itemize}

\subsubsection{Carrier Sets}
\label{carrier_sets}
\index{carrier set}
A new data type can be declared by adding its name -- an identifier -- to the \eventbsection{Sets} section.
The identifier must be unique, i.e. it must not have been already declared as a constant or set in an extended context.
The identifier is then implicitly introduced as a new constant (see below) that represents the set of all elements of the type. 

A common pattern for declaring enumerated sets (sets where all elements are explicitly given)
is to use the partition operator. If we want to specify a set $S$ with elements $e_1,\ldots,e_n$,
we declare $S$ as a set, $e_1,\ldots,e_n$ as constants and add the axiom $partition(S,e_1,\ldots,e_n)$.

\subsubsection{Extending a context}
Other contexts can be extended by adding their name to the \eventbsection{Extends} section.

The resulting context consists of all constants and axioms of all extended contexts and the extending context itself.
Thus for a context or machine that extends or sees the contexts, it makes no difference where a constant or axiom is declared.

Extending two contexts which declare a constant or set using the same identifier will result in an error.

\subsubsection{Constants and axioms}
\label{constants_and_axioms}
\index{constant}
\index{axiom}
Constants can be declared by adding their unique name (an identifier) to the \eventbsection{Constants} section.
An axiom must also be in place from which the type of the constant can be inferred.
We denote the sequence of all constants with $\varlist{c}$.

An axiom is a statement that is assumed as true in the rest of the model.
Each axiom consists of a label and a predicate $A(\varlist{c})$.

\index{theorem!axiom@axiom as theorem}
An axiom $A_{thm}$ can be marked as a theorem. In that case the following proof obligation is created:
%\podef{Proof obligation of a theorem}{\eventbpo{label/THM}}{the theorem}{axioms defined before the theorem and in extended contextes}
\pode{Proof obligation of a theorem}{\eventbpo{label/THM}}{$A_b(\allconstants) \limp A_{thm}(\allconstants)$}
where $A_b$ denotes (the conjunction of) all axioms declared in extended contexts and the axioms already declared in the current context before the theorem in question.

If an axiom $A$ contains any condition that is well-defined, a proof obligation is generated:
%\podef{Well-definedness of an axiom}{\eventbpo{label/WD}}{The axiom's WD-condition}{axioms defined before the theorem and in extended contextes}
\pode{Well-definedness of an axiom}{\eventbpo{label/WD}}{$A_b(\allconstants) \limp \wdl(A(\allconstants))$}.


\subsection{Machines}
\label{machine}
\index{machine}
A machine describes the dynamic behavior of a model by means of variables whose values are changed by events.

There are two basic things that must be proven for a machine:
\begin{enumerate}
	\item The machine must be consistent, i.e. it should never reach a state which violates the invariant.
	\item The machine is a correct refinement, i.e. its behavior must correspond to any machines that it refines
\end{enumerate}

\subsubsection{Refinement and Abstract machines}
\label{abstract_machine}
\index{abstract machine}
A machine can only refine one other machine. 
We refer to the refined machine as the abstract machine and refer to the refinement as the concrete machine. 
More generally, a machine $M_0$ can be refined by machine $M_1$, $M_1$ refined by $M_2$ 
and so on. The most concrete refinement would be $M_n$. 

Basically, a refinement consists of two aspects:
\begin{enumerate}
	\item The concrete machine's state is connected to the state of the
      abstract machine. To do this, an invariant is used to relate abstract and concrete variable. 
      \index{gluing invariant}
      This invariant is called a \emph{gluing invariant}. 
	\item Each abstract event can be refined by one or more
concrete events.
\end{enumerate}

The full invariant of the machine contists of both abstract and concrete invariants. 
The invariants are accumulated during refinements.

\info{\textbf{How to use Refinement:} Refinement can be used to subsequently add complexity to the model - this is called superposition refinement (or horizontal refinement).  It can also be used to add detail to data structures -- this is called data refinement (or vertical refinement).  We've seen both types of refinement in the tutorial (Chapter~\ref{tutorial}).
}

\subsubsection{Seeing a context}
If the machine sees a context, the sets and constants declared in the context can be used in
 all predicates and expressions.
The conjunction of axioms $A(\allconstants)$ can be used as hypotheses in the proofs.

\subsubsection{Variables and invariants}
\index{variable}
Variables can be declared by adding their unique name (an identifier) to the \eventbsection{Variables} section. The invariants of the machine must make the type of the variable clear.
We denote the variables of the abstract machines $M_1,\ldots,M_{n-1}$ with a $\absvariables$ and the variables of the concrete machine with a $\concvariables$.

\index{invariant}
An invariant is a statement that must hold at each state of the machine.
Each invariant $i$ consists of a label and a predicate $I_i(\allconstants,\absvariables,\concvariables)$.
An invariant can refer to the constants as well as the variables of the concrete and all abstract machines.

We write $I(\allconstants,\absvariables,\concvariables)$ to denote the conjunction of all invariants
of the machine and all its abstract machines. We call this the invariant of the machine.

\index{theorem!invariant@invariant as theorem}
An invariant $I_{thm}(\allconstants,\absvariables,\concvariables)$ can be marked as a theorem. In this case, the following proof obligation is generated:
\pode{An invariant as theorem}{\eventbpo{label/THM}}{$A(\allconstants) \land I_b(\allconstants,\absvariables,\concvariables) \limp I_{thm}(\allconstants,\absvariables,\concvariables)$}
where $I_b$ denotes (the conjunction of) all invariants declared in abstract machines and all invariants declared in the concrete machine before
the theorem in question.

Invariants that are marked as theorems derive their correctness from the preservation of other invariants (see below for details), so their preservation does not need to be proven.

If an invariant $I_i$ contains a well-definedness condition, the following proof obligation is generated:
\pode{Well-definedness of an invariant}{\eventbpo{label/WD}}{$A(\allconstants) \land I_b(\allconstants,\absvariables,\concvariables) \limp \wdl(I_i(\allconstants,\absvariables,\concvariables))$}

\paragraph{Common variables between machines}
\index{variable!common@common variable}
With some restrictions, the abstract variables $\absvariables$ and concrete
  variables $\concvariables$ can have variables in common.
If a variable $v$ is declared in a machine $M_i$, it can be re-used in the
  direct refinement $M_{i+1}$. 
In that case, it is assumed that the values of the abstract and concrete variable 
  are always equal.
To ensure this, special proof obligations are generated (see below in section \ref{events}).
Once a variable disappears in a refinement, i.e. is not declared in machine $M_{i+2}$,
  it cannot be re-introduced in a later refinement.

\subsubsection{Events}
\label{events}
\index{event}
A possible state change of a machine is defined by an event.
The condition under which an event can be executed is given by a guard. The event's action
describes how the new and old state relate to each other.

Events occur atomically (i.e. one event happens at a time) leading to a new state.
Two events never happen at the same time. Time is also not factored into the execution of the event.

An event has the following elements:
\begin{itemize}
\item Name
\item Parameters
\item Guards
\item Witnesses
\item Actions
\item Status (ordinary, convergent or anticipated): The status is used
  for termination proofs (see section~\ref{termination} for details).
\end{itemize}

An event can refine one or more events of an abstract machine. To keep things simple, we will
  first consider events with only one refined event.
If there are several refinement steps -- e.g. event $E_1$ is refined by $E_2$ and $E_2$ by
  $E3$, we call $E_1$ and $E_2$ the abstract events and $E_3$ the concrete event.
Likewise, if we refer to the parameters of the abstract events, we mean all the parameters
  of $E_1$ and $E_2$.

\paragraph{Parameters}
\index{parameter}
An event may have an arbitrary number of \emph{parameters}. Their names must be unique, i.e. there must be no constant or variable with the same name.
The types of the parameters must be inferable by the guards of the event.
We denote the parameters of all abstract events with $\absparameters$ and the
parameters of the concrete event with $\concparameters$.

Similarly to variables, an event can have parameters in common with the event it refines.
If the refined event has a parameter $t$ which is not a parameter of the refinement, 
a witness $W(\allconstants,\allvariables,\concparameters,t)$ for the abstract parameter must be specified (see below).

\paragraph{Guards}
\index{guard}
Each \emph{guard} consist of a label and a predicate $H(\allconstants,\concvariables,\concparameters)$.
Variables or parameters of abstract machines are not accessible in a guard.

We write $G(\allconstants,\absvariables,\absparameters)$ for the conjunction of all guards of all refined events.

\marginpar{Check the proof obligations and text for the role of witnesses and in the case of refinement}
Like axioms and invariants, guards can be marked as theorems too. The following
proof obligation is generated where $G_b$ denotes the conjunction of the guards occurring before the theorem:
%\podef{A guard as theorem}{\eventbpo{eventname/label/THM}}{the theorem}{axioms of seen contexts, invariants 
%  (also of refined machines), guards of the event that are declared before the theorem}
\pode{A guard as theorem}{\eventbpo{eventname/guardlabel/THM}}%
{$A(\allconstants) \land I(\allconstants,\absvariables,\concvariables) \land G_b(\allconstants,\concvariables,\concparameters) 
\limp G_{thm}(\allconstants,\concvariables,\concparameters)$}
If the guard $G_i$ contains WD-conditions, the following proof obligation is generated:
\pode{WD-condition of a guard}{\eventbpo{eventname/guardlabel/WD}}%
{$A(\allconstants) \land I(\allconstants,\absvariables,\concvariables) \land G_b(\allconstants,\concvariables,\concparameters) 
\limp \wdl(G_i(\allconstants,\concvariables,\concparameters))$}


\paragraph{Actions}
\label{actions}
An action is composed of a label and an assignment.
Section~\ref{assignments} gives an overview of how they are assigned.
They can be put into two groups: deterministic and non-deterministic assignments.
Each assignment affects one or more concrete variables.

If an event has more than one action, they are executed in parallel. 
An error will occur if a new value is assigned to a variable in more than one action.
All variables to which no new value is assigned keep the same value in new and old state.

\paragraph{Witnesses}
\label{witness}
\index{witness}

Witnesses are composed of a label and a predicate that are is to establish a link between the values 
  of the variables and parameters of the concrete and abstract events.
\warning{Unlike other elements in Event-B that have a label, the label of a witness has a meaning
  and cannot be chosen arbitrarily.}
If the user does not specify a witness, Rodin uses the default witness $\btrue$.

Witnesses are necessary in the following circumstances:
\begin{itemize}
\item The abstract event has a parameter $p$ that is not a parameter of the concrete
  event.
  In this case, the label of the witness must be $p$, and the witness has the form $W(\allconstants,\allvariables,\concparameters,p)$.
  (TODO: I did not check this, might be slightly different)
\item The abstract event assigns non-deterministically (using $\bcmin$ or $\bcmsuch$) 
  a value to a variable $x$ that is not a variable of the concrete machine.
  In this case, the label of the witness must be $x'$, the witness has the form $W(\allconstants,\allvariables,\allparameters,x')$.
\end{itemize}

\index{feasibility!of witnesses}
The validity of the witness must be proven, i.e. that $x$ is a place-holder for the parameter $p$ or variable $v'$ for which the witness is written.
\pode{Witness feasibility}{\eventbpo{eventlabel/witnesslabel/WFIS}}%
  {$A(\allconstants) \land I(\allconstants,\absvariables) \land J(\allconstants,\allvariables) \land
    \concbeforeafter(\allconstants,\concparameters,\concvariables,\concvariables') \limp
    W(\allconstants,\allvariables,\allparameters,x)$}
A witness $W(\allconstants,\allvariables,\allparameters,x)$ may contain well-definedness conditions.
\pode{Well-definedness of a witness}{\eventbpo{eventlabel/witnesslabel/WWD}}%
  {TODO}

\subparagraph{Witness (TODO: From Wiki)}

When a concrete event refines an abstract one which is parameterized, then all abstract parameters must receive a value in the concrete event. Such values are called the witnesses. Each witness is labelled with the concerned abstract parameter. The witness is defined by a predicate involving the abstract parameter. Most of the time, this predicate is a simple equality. Next is an example showing two witnesses. On the left hand side we have an abstract event named pass with two parameters. On the right hand side we have a concrete event named new\_pass refining pass 

$\begin{array}{l} \texttt{pass} \ \ \defi \\ \quad \textbf{any} \\ \quad \quad p \\ \quad \quad l \\ \quad \textbf{where}\\ \quad \quad grd1: \ \ {p \mapsto l \,\in\, aut}\\ \quad \quad grd2: \ \ sit(p)\mapsto l \,\in\, com \\ \quad \textbf{then} \\ \quad \quad act1: \ \ sit(p) \,:=\, l \\ \quad \textbf{end} \end{array}
\begin{array}{l} \texttt{new\_pass} \ \ \defi \\ \quad \textbf{refines} \\ \quad \quad \texttt{pass} \\ \quad \textbf{any} \\ \quad \quad d \\ \quad \textbf{where}\\ \quad \quad grd1: \ \ \ d \,\in\, ran(dap) \\ \quad \textbf{with} \\ \quad \quad p: \ \ \ p=dap^{-1}(d) \\ \quad \quad l: \ \ \ l=dst(d) \\ \quad \textbf{then} \\ \quad \quad act1: \ \ sit(dap^{-1}(d)) \,:=\, dst(d) \ \\ \quad \quad act2: \ \ dap \,:=\, dap \ransub \{d\} \\ \quad \textbf{end} \end{array} $

When the concrete event is also parameterized then an abstract parameter which is the same as a concrete need not be given an explicit witness: it is always the corresponding concrete parameter.

The initialisation event sometimes needs witnesses, in this case do not forget to use the after value of variable (x'). 

\paragraph{Initialization}
\index{initialization}
The initialization of a machine is given by a special event called \textsl{INITIALISATION}.
Unlike other events, the initialization must not contain guards and parameters.
The actions must not make use of variable values before the initialization event occurs.
All variables must have a value assigned to them. If there is no assignment for the variable $x$, Rodin assumes a default assignment of the form $x\bcmsuch \btrue$.

\paragraph{Ensuring machine consistency}
\label{consistency_proof_obligations}
The following proof obligations are generated for events:

The assignment $a$ of each action with the label $\eventbpo{actionlabel}$ of an event must be well-defined.
  \pode{Well-definedness of actions}%
  {\eventbpo{eventlabel/actionlabel/WD}}%
  {$A(\allconstants) \land I(\allconstants,\allvariables) \land G(\allconstants,\concvariables,\concparameters) \limp %
    \wdl(~a~)$}
  
\index{feasibility!of actions}
If the event's guard is enabled, every action must be feasible.
  This is trivially true in the case of the deterministic assignments.
  For a non-deterministic assignment $a$, the feasibility $\actfis(a)$ must be proven.
  The feasibility operator $\actfis$ is defined in the reference
  section regarding non-deterministic assignments.
  
  \pode{Action feasibility}{\eventbpo{eventlabel/actionlabel/FIS}}%
  {$A(\allconstants) \land I(\allconstants,\allvariables) \land G(\allconstants,\concvariables,\concparameters) \limp \actfis(a)$}

For each invariant $I_i$ with the label \eventbpo{invlabel} 
  that contains a variable affected by the assignment, it must be proven
  that the invariant still holds with the new values.
  \pode{Invariant preservation}%
  {\eventbpo{eventlabel/invlabel/INV}}%
  {$A(\allconstants) \land I(\allconstants,\allvariables) \land G(\allconstants,\concvariables) \limp I_i(\allconstants,\allvariables')$}
  Rodin simplifies this proof obligations by replacing $x'$ with $x$ for variables that are not
  changed and $x'$ by $E(\allconstants,\concvariables,\concparameters)$ 
  for variables that are assigned by an deterministic ($x \bcmeq E$) assignment.

There are special cases regarding initialisation:
  \pode{Action feasibility (in the initialisation)}{\eventbpo{INITIALISATION/actionlabel/FIS}}%
  {$A(\allconstants) \limp  \actfis(a)$}
  \pode{Invariant establishment}%
  {\eventbpo{INITIALISATION/invlabel/INV}}%
  {$A(\allconstants) \limp I_i(\allconstants,\allvariables')$}

\subsubsection{Ensuring a correct refinement}
\label{refinement_proof_obligations}
An event can refine one or more events of the abstract machine.
We first consider the refinement of only one event. 
For refining more than one event (i.e. merging events), please see below in section~\ref{merging_events}.


A concrete event must only be enabled if the abstract event is enabled.
This condition is called \emph{guard strengthening}.


\subsubsection{Merging events}
\label{merging_events}
(This section will be written in a later iteration.)

\subsubsection{Extending events}
\index{superposition refinement}
\label{extending_events}
(This section will be written in a later iteration.)
``Superposition'' should be mentioned here.


\subsubsection{Termination}
\label{termination}
\index{variant}
\index{status of an event}
\index{ordinary (status)}\index{anticipated (status)}\index{convergent (status)}
(This section will be written in a later iteration.)

The variant section appears in a refined machine (section 1) containing some convergent or anticipated events (section 2). This machine section contains either a natural number expression which must be decreased by each convergent event and not be increased by each anticipated event, or a finite set expression which must be made strictly smaller by each convergent event or not made greater by each anticipated events. 

  
\subsection{Generated proof obligations}
\label{ref:generated_proof_obligations}

We give a brief overview about which POs are generated. This should help the user to identify the why a PO generated when he can identify its label.

Proof obligations (abbreviated as PO) are generated by the proof obligation generator and have the form of sequents. The following tables list the different PO and their associated name.

This table describes the names of context proof obligations: 

\begin{center}
    \begin{tabular}{| p{6cm} | p{3cm} | p{5cm} |}
    \hline
	Well-definedness of an Axiom & $m$ / WD & $m$ is the axiom name\\ \hline
	Well-definedness of a Derived Axiom & $m$  / WD & $m$ is the axiom name \\ \hline
	Derived Axiom & $m$  / THM & $m$ is the axiom name \\ \hline
    \end{tabular}
\end{center}

This table shows the name of machine proof obligations:

\begin{center}
    \begin{tabular}{| p{6cm} | p{3cm} | p{5cm} |}
    \hline
	Well-definedness of an Invariant & $v$  / WD & $v$ is the invariant name\\ \hline
	Well-definedness of a Derived Invariant & $m$  / WD & $m$ is the invariant name \\ \hline
	Well-definedness of an event Guard & $t$  / $d$  / WD & $t$ is the event name, $d$ is the action name  \\ \hline
	Well-definedness of an event Action & $t$  / $d$  / WD & $t$ is the event name, $d$ is the action name  \\ \hline
	Feasibility of a non-det. event Action & $t$  / $d$  / FIS & $t$ is the event name, $d$ is the action name  \\ \hline
	Derived Invariant & $m$ / THM & $m$ is the invariant name \\ \hline
	Invariant Establishment & INIT.  / $v$  / INV & $v$ is the invariant name  \\ \hline
	Invariant Preservation & $t$  / $v$  / INV & $t$ is the event name, $v$ is the invariant name  \\ \hline
    \end{tabular}
\end{center}

This table shows the proof obligations concerned with machine refinements:

\begin{center}
    \begin{tabular}{| p{6cm} | p{3cm} | p{5cm} |}
    \hline
	Guard Strengthening & $t$  / $d$  / GRD & $t$ is the concrete event name, $d$ is the abstract guard name\\ \hline
	Guard Strengthening (merge) & $t$  / MRG & $t$ is the concrete event name \\ \hline
	Action Simulation & $t$  / $d$  / SIM & $t$ is the concrete event name, $d$ is the abstract action name  \\ \hline
	Equality of a preserved Variable & $t$  / $v$  / EQL & $t$ is the concrete event name, $v$ is the preserved variable  \\ \hline
    \end{tabular}
\end{center}

This table shows the proof obligations concerned with the new events variant:

\begin{center}
    \begin{tabular}{| p{6cm} | p{3cm} | p{5cm} |}
    \hline
	Well definedness of Variant & VWD & \\ \hline
	Finiteness for a set Variant & FIN &  \\ \hline
	Natural number for a numeric Variant & $t$  / NAT & $t$ is the new event name \\ \hline
	Decreasing of Variant & $t$  / VAR & $t$ is the new event name  \\ \hline
    \end{tabular}
\end{center}

Finally, this table shows are the proof obligations concerned with witnesses:

\begin{center}
    \begin{tabular}{| p{6cm} | p{3cm} | p{5cm} |}
    \hline
	Well definedness of Witness & $t$  / $p$  / WWD & $t$ is the concrete event name, $p$ is parameter name, or a primed variable name \\ \hline
	Feasibility of non-det. Witness & $t$  / $p$  / WFIS & $t$ is the concrete event name, $p$ is parameter name, or a primed variable name \\ \hline
    \end{tabular}
\end{center}

Remark: At the moment, the proof obligation generation for deadlock freeness is missing. If you need it, you can generate it yourself as a derived invariant by saying that the disjunction of the abstract guards imply the disjunction of the concrete guards.

\subsection{Visibility of identifiers}
\label{visibility_of_identifiers}

This table shows which identifiers can be used in predicates or expressions. 
\begin{description}
\item[Sets] Sets that are defined in the context (in case of an axiom) or in a seen context.
  If a context extends another context, the sets of the extended context are treated as if they
  are defined in the extending context.
\item[Constants] Like the sets, constants that are defined in the context (in case of an axiom) or
  in a seen context.
\item[Concrete Variables] Variables that are defined in the machine itself. This does \emph{not}
  include variables of refined machines.
\item[Abstract Variables] Variables that are defined in an abstract machine.
\item[Concrete Parameters] Parameters that are defined in the event itself. This does \emph{not}
  include parameters of refined events.
\item[Abstract Parameters] Parameters that are defined in an abstract event.
\end{description}

\begin{center}
  \newcommand{\markcell}{$\times$}
  \begin{tabular}{lcccccc}
  \hline
            &           &           & concrete  & abstract  & concrete   & abstract \\
            & sets      & constants & variables & variables & parameters & parameters \\
  \hline
  axiom     & \markcell & \markcell &           &           &            & \\
  invariant & \markcell & \markcell & \markcell & \markcell &            & \\
  variant   & \markcell & \markcell & \markcell & \markcell &            & \\
  guard     & \markcell & \markcell & \markcell & \markcell & \markcell  & \\
  witness$^{*}$   & \markcell & \markcell & \markcell & \markcell & \markcell  & \markcell \\
  action$^{*}$    & \markcell & \markcell & \markcell & \markcell & \markcell  &  \\
  \hline
  \end{tabular}    
\end{center}


\subsection{Well-Definedness}

In classical set theory (see, e.g., H. B. Enderton, Elements of Set Theory, Academic Press, 1977), the formula $1\div 0 = 1\div 0$ is true, because $1\div 0$ denotes some set or number; we just do not know which one. In Event-B however, $1\div 0$ does not denote a particular set or number and therefore receives a specialized treatment. The formula $1\div 0 = 1\div 0$ is then neither true nor false; it is ill-defined.

Formally, there is a syntactic transformation $\mathcal{D}$ mapping terms and formulae to a well-definedness condition, which itself is a formula. The term or formula E is well-defined iff $\mathcal{D}(E)$ can be proved and otherwise ill-defined. For example:

    $\mathcal{D}(x\div y) \defi y \neq 0.$
    $\mathcal{D}(\phi\lor\psi)\defi(\mathcal{D}(\phi)\land\mathcal{D}(\psi))\lor(\mathcal{D}(\phi)\land\phi)\lor(\mathcal{D}(\psi)\land\psi).$
    $\mathcal{D}(y=0 \lor (x\div y) * y = x)$ is equivalent to $y\neq0 \lor y = 0, whence y\neq0\limp(x\div y)*y=x$ is well-defined.
    Because $\mathcal{D}$ preserves the symmetry of disjunction, $(x\div y)*y=x \lor y = 0$ is also well-defined. 

Well-definedness is similar to well-typedness, just that checking well-definedness is undecidable, because it involves finding a proof.

As $\mathcal{D}(E)$ in the worst case grows exponentially in the size of E, it is not computed directly in the Rodin platform. Instead another syntactic transformation $\mathcal{L}$ is defined, and $\mathcal{D}(E)$ is approximated by $\mathcal{L}(E)$. In the case of disjunction, $\mathcal{L}(\phi\lor\psi)\defi\mathcal{L}(\phi)\land(\lnot\phi\limp\mathcal{L}(\psi))$, which is equivalent to the first two disjuncts of $\mathcal{D}(\phi\lor\psi)$. One may therefore view $\mathcal{L}(E)$ as an incomplete strategy for proving $\mathcal{D}(E)$. Approximating $\mathcal{D}$ by $\mathcal{L}$ is sound, because $\mathcal{L}(E)\limp\mathcal{D}(E)$ is always provable. 

Nomenclature

In this article the following nomenclature is used:

    1 + 1 = 2 is a formula.
    1 + 1 is a term.
    + is an operator.
    = is a predicate. 

In other places (but not in this wiki-page), 1 + 1 = 2 is called predicate and 1 + 1 expression.
[edit] D-Well-Definedness
[edit] Definition

We associate with each operator f a domain condition $\mathcal{DOM}(f)$. Informally, the domain condition of an operator determines which terms the operator may be applied to. Formally, if $f(\mathbf{t})$ is a term, then $\mathcal{DOM}(f)(\mathbf{t})$ is a formula. Intuitively, if $f(\mathbf{t})$ is a (well-typed) term, $\mathcal{DOM}(f)(\mathbf{t})$ is true if and only if $\mathbf{t}$ belongs to the "intended domain" of f.

For example,

    $\mathcal{DOM}(\div)(t, u) \defi u \neq 0$,
    $\mathcal{DOM}(\mathrm{app})(r,x)) \defi x \in \dom(r) \land r \in A \pfun B$, assuming that r is of type $\pow(A \times B)$. 

Here the operator app takes a function r and a value x and returns the result of applying r to x.

The various domain conditions can be found in the Event-B mathematical language description.

Based on the domain conditions, we associate with each term or formula E a well-definedness condition $\mathcal{D}(E)$, respectively. Well-definedness conditions are formulae as follows:
(x ranges over variables, f over operators, p over predicates, $\mathbf{t}$ over sequences of terms of length $|\mathbf{t}|$, and $φ$, $ψ$ over formulae. All terms and formulae are well-formed and well-typed.)

    $\mathcal{D}(x)\defi \btrue$,
    $\mathcal{D}(f(\mathbf{t}))\defi \mathcal{DOM}(f)(\mathbf{t}) \land \bigwedge_{i=1}^{|\mathbf{t}|} \mathcal{D}(t_i)$,
    $\mathcal{D}(\{x\mid \phi\})\defi \forall x\qdot \mathcal{D}(\phi)$,
    $\mathcal{D}(p(\mathbf{t}))\defi \bigwedge_{i=1}^{|\mathbf{t}|} \mathcal{D}(t_i)$,
    $\mathcal{D}(\btrue) \defi \mathcal{D}(\bfalse) \defi \btrue$,
    $\mathcal{D}(\lnot\phi) \defi \mathcal{D}(\phi)$,
    $\mathcal{D}(\phi\land\psi)\defi (\mathcal{D}(\phi) \land \mathcal{D}(\psi)) \lor (\mathcal{D}(\phi) \land \lnot\phi) \lor (\mathcal{D}(\psi) \land \lnot\psi)$,
    $\mathcal{D}(\phi\lor\psi)\defi (\mathcal{D}(\phi) \land \mathcal{D}(\psi)) \lor (\mathcal{D}(\phi) \land \phi) \lor (\mathcal{D}(\psi) \land \psi)$,
    $\mathcal{D}(\phi\limp\psi)\defi (\mathcal{D}(\phi) \land \mathcal{D}(\psi)) \lor (\mathcal{D}(\phi) \land \lnot\phi) \lor (\mathcal{D}(\psi) \land \psi)$,
    $\mathcal{D}(\phi\leqv\psi)\defi \mathcal{D}(\phi) \land \mathcal{D}(\psi)$,
    $\mathcal{D}(\forall x\qdot \phi)\defi (\forall x \qdot \mathcal{D}(\phi)) \lor (\exists x \qdot \mathcal{D}(\phi) \land \lnot \phi)$,
    $\mathcal{D}(\exists x\qdot \phi)\defi (\forall x \qdot \mathcal{D}(\phi)) \lor (\exists x \qdot \mathcal{D}(\phi) \land \phi)$. 

A constant c is an operator of arity zero and therefore has the well-definedness condition $\mathcal{DOM}(c)()$, which equals $\btrue$ for all currently supported constants.

Intuitively, the well-definedness condition of a term or formula is true if and only if the term or formula can be evaluated without applying an operator to an argument outside of its domain.

Well-Definedness and Provability

Recall that the set of provable sequents is the smallest set of sequents such that if all antecedents of some inference rule are provable then so is the consequent. See Inference Rules and All Rewrite Rules for an incomplete list of rules that may be used to prove a sequent. (Here we view rewrite rules also as inference rules.) In the future, more rules will be added to this list so that more sequents will be provable. In particular, the following rules may also be used to prove a sequent:

TODO FORMULA!

A formula $φ$ is provable if and only if the sequents $\vdash\phi and \vdash\mathcal{D}(\phi)$ are provable.

It can be checked (see F. D. Mehta, Proofs for the working engineer, Diss. ETH Zurich, 2008) that for each term or formulae E the formula $\mathcal{D}(E)$ is provable iff $\vdash\mathcal{D}(E)$ is provable. We therefore say that a term or formula is well-defined iff its well-definedness condition is provable. A term or formula is ill-defined iff it is not well-defined.

Informally, well-definedness conditions appear in two ways during proofs:

    When proving a formula, we also have to prove its well-definedness.
    When proving a sequent, we may always assume that the hypotheses and the goal of the sequent are well-defined. 

L-Well-Definedness

As $\mathcal{D}(E)$ in the worst case grows exponentially in the size of E, $\mathcal{D}$ is never evaluated explicitely in the Rodin platform. To avoid evaluating $\mathcal{D}$, we define the syntactic transformation $\mathcal{L}$ as follows:
(Again, x ranges over variables, f over operators, p over predicates, $\mathbf{t}$ over sequences of terms of length $|\mathbf{t}|$, and $φ$, $ψ$ over formulae. All terms and formulae are well-formed and well-typed.)

    $\mathcal{L}(x)\defi \btrue$,
    $\mathcal{L}(f(\mathbf{t}))\defi \mathcal{DOM}(f)(\mathbf{t}) \land \bigwedge_{i=1}^{|\mathbf{t}|} \mathcal{L}(t_i)$,
    $\mathcal{L}(\{x\mid \phi\})\defi \forall x\qdot \mathcal{L}(\phi)$,
    $\mathcal{L}(p(\mathbf{t}))\defi \bigwedge_{i=1}^{|\mathbf{t}|} \mathcal{L}(t_i)$,
    $\mathcal{L}(\btrue) \defi \mathcal{L}(\bfalse) \defi \btrue$,
    $\mathcal{L}(\lnot\phi) \defi \mathcal{L}(\phi)$,
    $\mathcal{L}(\phi\land\psi)\defi \mathcal{L}(\phi) \land (\phi \limp \mathcal{L}(\psi))$,
    $\mathcal{L}(\phi\lor\psi)\defi \mathcal{L}(\phi) \land (\lnot\phi \limp \mathcal{L}(\psi))$,
    $\mathcal{L}(\phi\limp\psi)\defi \mathcal{L}(\phi) \land (\phi \limp \mathcal{L}(\psi))$,
    $\mathcal{L}(\phi\leqv\psi)\defi \mathcal{L}(\phi) \land \mathcal{L}(\psi)$,
    $\mathcal{L}(\forall x\qdot \phi)\defi \forall x\qdot \mathcal{L}(\phi)$,
    $\mathcal{L}(\exists x\qdot \phi)\defi \forall x\qdot \mathcal{L}(\phi)$. 

Only Conditions 7, 8, 9, 11, 12 differ from the corresponding conditions in the definition of $\mathcal{D}$.

The two syntactic transformations $\mathcal{D}$ and $\mathcal{L}$ are related as follows:

    $\mathcal{L}(E) \limp \mathcal{D}(E)$ is provable for every term or formula E.

Based on this observation, the transformation $\mathcal{D}$ is avoided in Rodin's proof calculus as follows:

    To prove φ, the user has to prove $\vdash\phi$ and $\vdash\mathcal{L}(\phi)$.
    If an inference rule contains well-definedness conditions $\mathcal{D}(E)$, the rule may not be added to the list of rules available in Rodin.
        If the well-definedness conditions $\mathcal{D}(E)$ only appear as goals of antecedents and hypotheses of the consequent, the rule obtained by replacing $\mathcal{D}(E)$ by $\mathcal{L}(E)$ is made available in Rodin. For example, instead of adding the rule

        TODO FORMULA!
        the rule 
        TODO FORMULA!
        is added to the list of inference rules. 

        If a well-definedness condition $\mathcal{D}(E)$ appears as a hypothesis of an antecedent or as the goal of the consequent, the rule may not be added to the list of rules available in Rodin. Therefore the above rules (*) are unavailable in Rodin. 

Note that avoiding $\mathcal{D}$ in Rodin's proof calculus is not necessary for soundness; it is just a way of making sequents arising in proofs smaller. The price of avoiding $\mathcal{D}$ in Rodin's proofs is that some formulae and sequents become unprovable.
[edit] Distinction between D and L

As $\mathcal{L}(E)$ is stronger than $\mathcal{D}(E)$, mixing them up easily leads to inconsistency in Rodin's proof calculus. To help the reader differentiate between the two syntactic transformations $\mathcal{D}$ and $\mathcal{L}$, we provide a summary of what is used where:

    In the documentation of Inference rules (Inference Rules and All Rewrite Rules), "WD" refers to $\mathcal{L}$.
    In the Rodin source code, the term "well-definedness predicate" refers to $\mathcal{L}(E)$, and (at the time of writing) the API of org.eventb.core.ast provides no method for computing $\mathcal{D}$.
    In Rodin, the goal of a well-definedness proof obligation is created by $\mathcal{L}$.
    The above rules (*) are sound, but the analog rules with $\mathcal{D}$ replaced by $\mathcal{L}$ are not, and they may therefore neither be added to the proof calculus nor be used to justify new inference rules. 

[edit] Design Decisions Revisited

In the following, we review some properties of the syntactic transformation $\mathcal{DOM}$, which should be preserved when introducing new operators and predicates in Event-B. We also list some properties of $\mathcal{D}$ and $\mathcal{L}$ to illustrate some design decisions underlying their definitions.
[edit] Important Properties of DOM

Technically, domain conditions map sequences of terms to formulae. But not every such mapping may be used as a domain condition.

    Only variables appearing in the sequence $\mathbf{x}$ of variables appear free in $\mathcal{DOM}(f)(\mathbf{x})$.
    $\mathcal{DOM}(f)(\mathbf{t}) \defi \mathcal{DOM}(f)(\mathbf{x})[\mathbf{x}\bcmeq\mathbf{t}]$.
    $\mathcal{DOM}(f)(\mathbf{x})$ syntactically only contains definite operators. An operator f is definite iff $\mathcal{DOM}(f)(\mathbf{x})\defi\btrue$ for every sequence $\mathbf{x}$ of variables of appropriate length and type. 

Property 3 ensures that $\mathcal{D}(E)$ is provable if and only if $\vdash\mathcal{D}(E)$ is provable. In the future, Property 3 may be replaced by a weaker version.
[edit] Important Properties of D and L
[edit] L is stronger than D

$\mathcal{L}(E) \limp \mathcal{D}(E)$ is provable for each term or formula E.
[edit] Monotonicity

We define the order $\sqsubseteq$ on terms and formulae by

    $t \sqsubseteq u iff \mathcal{D}(t)\limp t=u$ is provable, and
   $ \phi\sqsubseteq\psi iff \mathcal{D}(\phi)\limp (\phi\leqv\psi) is provable$. 

Then, $\mathcal{D}$ has the following monotonicity properties (TODO: add citation):
(u, v are terms, x is a variable, ψ, χ are formulae, E is a term or a formula, and p is a position in E.)

    If $u \sqsubseteq v, then E[x\bcmeq u] \sqsubseteq E[x\bcmeq v]$.
    If $\psi \sqsubseteq \chi, then E_p[\psi] \sqsubseteq E_p[\chi]$.

Here, Ep[ψ] denotes the term or formula obtained by replacing the subformula at position p in E by ψ. We assume that bound variables of E do not appear free in ψ or χ, which can be achieved by consistent renaming of variables.

The above monotonicity properties are crucial for the soundness of several rewrite rules, such as t * 0 $\defi 0$.

It is possible to prove similar monotonicity properties for $\mathcal{L}$ but monotonicity of $\mathcal{L}$ is not necessary for soundness of any inference rule.
[edit] Strictness

We have decided to make operators strict, i.e., if some element in the list of terms $\mathbf{t}$ is ill-defined, then so is $f(\mathbf{t})$, where f is an operator. Predicates are also strict.

The strictness property can be dropped without making any inference rule unsound, as long as the monotonicity properties of the previous section are preserved. An example for a non-strict operator retaining the monotonicity property is lazy multiplication mult: the term mult(t,u) denotes the same value as t * u if both t and u are well-defined, it denotes 0 if either t or u denotes 0, and it is ill-defined otherwise.
[edit] Predicates and Sets are Definite

We have decided to make predicates definite, i.e., a formula $p(t)$ is well-defined provided each element of $t$ is. Therefore, sets are also definite, i.e., $t \in A$ is well-defined provided t and A are.

It may be possible to allow for indefinite predicates and sets without compromising soundness of the proof calculus. In that case, it may be desirable to retain soundness of the following rewrite rules:
$p(t) \defi t \in \{x\mid p(x)\}$
$t\in\{x\mid p(x)\} \defi p(t)$
(t is a term, p a predicate, and x a variable.) 


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "rodin-doc"
%%% End: 
