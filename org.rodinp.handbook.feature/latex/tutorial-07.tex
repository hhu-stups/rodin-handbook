\section{Expanding the Traffic Light System: Contexts and Refinement}
\label{tutorial_07}

\tick{\textbf{Goals:} We apply what we learned in the previous section by introducing a context with traffic light colors and a refinement to integrate them. We will also introduce another refinement for the push buttons.}

\subsection{Data Refinement}
\label{tutorial:data_refinement}

We will continue the example from Section~\ref{tutorial_03}, where we built a simplified model of a traffic light controller.  The model was simplified because we abstracted the traffic lights to TRUE and FALSE and a number of features were still missing.

We will introduce data refinement in this section.  The objective is to create a mapping between the abstract traffic light values and actual colors. Figure \ref{fig_tut_07_tl_colors} depicts our mapping for the traffic light.

\begin{figure}[!h]
\begin{center}
	\includegraphics{img/tutorial/tl-colors.png}
	\caption{Mapping between Abstract and Concrete Events}
	\label{fig_tut_07_tl_colors}
\end{center}
\end{figure}

For simplicity, the traffic light for pedestrians consists of only two lights: red and green.

We break this problem into two steps:

\begin{enumerate}
	\item Create a context with the data structures for the colors.
	\item Create a refinement of the existing model that sees the new context and refines the boolean states into colors.
\end{enumerate}

\subsection{A Context with Colors}

Start by creating a context called \texttt{ctx1}, as described in Section~\ref{tutorial_05}.
We model the colors as constants:

\pencil{
\begin{description}
\CONSTANTS
	\begin{description}
		\Item{ red }
		\Item{ yellow }
		\Item{ green }
	\end{description}
\end{description}
}

These constants are part of a set:

\pencil{
\begin{description}
\SETS
	\begin{description}
		\Item{ COLORS }
	\end{description}
\end{description}
}

And last, we need to provide typing.  We do this by creating a partition (\ref{partition}):

\pencil{
\begin{description}
\AXIOMS
	\begin{description}
		\nItemX{ type }{ partition(COLORS, \{ red\} , \{ yellow\} , \{ green\} ) }
	\end{description}
\end{description}
}

\warning{Please note the curly braces \{\} around the colors.  It's very easy to forget these, which will result in typing errors that are very hard to interpret for a novice.
}

This completes the context.

\subsection{The Actual Data Refinement}

The easiest way to create a refinement is by right-clicking on the machine in the project browser and selecting \textsf{Refine}.  This will create a ``stub'' consisting of all variables and events.

TODO: Screenshot of selecting the context menu.

\warning{In refinements, the \textsf{Edit} View of the Editor hides some information from the abstract machine by default.  This can be particularly important when you modify a refined event.  The \textsf{Pretty Print} View shows all the element with elements from the abstract machine in \textit{italics}.}

First we have to make the machine aware of the context by adding a \textsf{sees} (\ref{sees}) statement:

\pencil{
\begin{description}
\MACHINE{mac1}
\REFINES{mac0}
\SEES{ctx1}
\end{description}
}

We start with the traffic lights for the pedestrians, which consists of just two colors (red and green).  We introduce a new variable to represent the traffic light colors called \textsf{peds\_colors}, with corresponding typing and an initialization (only the changes are shown in the following):

\pencil{
\begin{description}
\VARIABLES
	\begin{description}
		\Item{ peds\_colors }
	\end{description}
\INVARIANTS
	\begin{description}
		\nItemX{ inv4 }{ peds\_colors \in  \{  red, green \}  }
	\end{description}
\EVENTS
	\INITIALISATION
		\\\textit{extended}
		\begin{description}
		\BeginAct
			\begin{description}
			\nItemX{ init4 }{ peds\_colors :=  red }
			\end{description}
		\EndAct
		\end{description}
\END
\end{description}
}

Next, we will create a gluing invariant (\ref{gluing_invariant}) that associated \textsf{peds\_go} from the abstract machine with the variable \textsf{peds\_colors} that we just created.  The gluing invariant shall map \textsf{TRUE} to \textsf{green} and \textsf{FALSE} to \textsf{red}:

\pencil{
\begin{description}
\INVARIANTS
	\begin{description}
		\nItemX{ gluing }{ peds\_go = TRUE \leqv  peds\_colors = green }
	\end{description}
\end{description}
}

In its current state, this gluing invariant can be violated: if the event \textsf{set\_peds\_go} is triggered, for instance, the variable \textsf{peds\_go} will change, but not \textsf{peds\_colors}.  We expect that this will result in undischarged proof obligations \ref{undischarged_proof_obligations}.  We can check this by expanding the machine in the Event-B Explorer.  Indeed, we now see two undischarged proof obligations (compare with figure \ref{fig_tut_07_undischarged}).

\begin{figure}[!h]
\begin{center}
	\includegraphics{img/tutorial/undischarged1.png}
	\caption{Mapping between Abstract and Concrete Events}
	\label{fig_tut_07_undischarged}
\end{center}
\end{figure}

To fix this, we have to modify the two events in question.  Let's start with \textsf{set\_peds\_go}.  First, we change the event from extended to not extended in the Editor as shown in figure \ref{fig_tut_07_event_refinement}.

\begin{figure}[!h]
\begin{center}
	\includegraphics{img/tutorial/event-refinement.png}
	\caption{Switch from extended to not extended}
	\label{fig_tut_07_event_refinement}
\end{center}
\end{figure}

This change will copy the guard and action from the abstract machine, so that we can modify it.  We can now replace the action with the corresponding action regarding \textsf{peds\_colors} (setting it to \textsf{go}).  While we are at it, we can also rename the name of the event to something more fitting (e.g. \textsf{set\_peds\_green}).

Next, we perform the corresponding change on \textsf{set\_peds\_stop}.  And last, \textsf{set\_cars} also contains a reference to \textsf{peds\_go} that must be replaced.

Once all references to \textsf{peds\_go} have been replace, we can remove the variable \textsf{peds\_go} from the \textsf{VARIABLES} section.  You shouldn't have any errors or warnings, and all proof obligations should be discharged.

\warning{If you get the error message ``Identifier peds\_go has not been declared'', then there are references to the refined variable left somewhere in the model.  It can be helpful to use the \textsf{Pretty Print} view, as it will show the ``inherited'' elements from the abstract machine as well.}

\subsection{The refined machine with data refinement for peds\_go}

\pencil{
\begin{description}
\MACHINE{mac1}
\REFINES{mac0}
\SEES{ctx1}
\VARIABLES
	\begin{description}
		\Item{ cars\_go }
		\Item{ peds\_colors }
	\end{description}
\INVARIANTS
	\begin{description}
		\nItemX{ inv4 }{ peds\_colors \in  \{  red, green \}  }
		\nItemX{ gluing }{ peds\_go = TRUE \leqv  peds\_colors = green }
	\end{description}
\EVENTS
	\INITIALISATION
		\begin{description}
		\BeginAct
			\begin{description}
			\nItemX{ act1 }{ cars\_go :=  FALSE }
			\nItemX{ init4 }{ peds\_colors :=  red }
			\end{description}
		\EndAct
		\end{description}
	\EVT {set\_peds\_green}
	\REF {set\_peds\_go}
		\begin{description}
		\WhenGrd
			\begin{description}
			\nItemX{ grd1 }{ cars\_go = FALSE }
			\end{description}
		\ThenAct
			\begin{description}
			\nItemX{ act2 }{ peds\_colors :=  green }
			\end{description}
		\EndAct
		\end{description}
	\EVT {set\_peds\_red}
	\REF {set\_peds\_stop}
		\begin{description}
		\BeginAct
			\begin{description}
			\nItemX{ act1 }{ peds\_colors :=  red }
			\end{description}
		\EndAct
		\end{description}
	\EVT {set\_cars}
	\REF {set\_cars}
		\begin{description}
		\AnyPrm
			\begin{description}
			\ItemX{ new\_value }
			\end{description}
		\WhereGrd
			\begin{description}
			\nItemX{ grd1 }{ new\_value \in  BOOL }
			\nItemX{ grd2 }{ new\_value = TRUE \limp  peds\_colors = red }
			\end{description}
		\ThenAct
			\begin{description}
			\nItemX{ act1 }{ cars\_go :=  new\_value }
			\end{description}
		\EndAct
		\end{description}
\END
\end{description}
}

\subsection{Witnesses}

The refinement of \textsf{set\_cars} is more difficult, as the event uses a parameter (the new value for \textsf{cars\_go}).  In order to create the association, we need a witness (\ref{witness}).

A witness is for an event's parameter what a gluing invariant is for a variable: it is a mapping between the abstract parameter and the new parameter and allows the abstract parameter to disappear.  In this example, the abstract parameter \textsf{new\_value} is of type \textsf{BOOL}, while we introduce a new parameter \textsf{new\_value\_colors} of type \textsf{COLORS}.

\warning{The naming of a witnesses' label is mandatory and must be the name of the abstract parameter.  In our example, the label must be \textsf{new\_value}}

So let's get started.  We first provide the new variable, gluing invariant, typing invariant and initialization as before.  Note that the traffic light for the cars can show more than one color at a time.  Therefore, the variable contains a set of colors, instead of just one color (as modelled for \textsc{peds\_colors}):

\pencil{
\begin{description}
\VARIABLES
	\begin{description}
		\Item{ cars\_colors }
	\end{description}
\INVARIANTS
	\begin{description}
		\nItemX{ inv5 }{ cars\_colors \subseteq  COLORS }
		\nItemX{ gluing\_cars }{ cars\_go = TRUE \leqv  green \in  cars\_colors }
	\end{description}
\EVENTS
	\INITIALISATION
		\begin{description}
		\BeginAct
			\begin{description}
			\nItemX{ init5 }{ cars\_colors :=  \{  red \}  }
			\end{description}
		\EndAct
		\end{description}
	\END
\end{description}
}

We also have to modify the guard on \textsf{set\_peds\_green}, something that you should now be able to figure out yourself.

The interesting piece is the last event, \textsf{set\_cars}, which we rename into \textsf{set\_cars\_colors}.  We change the parameter to \textsf{new\_value\_colors} and type it as a subset of \textsf{COLORS}.

The witness appears in the \textsf{with} section of the event.  The label \textbf{must} be \textsf{new\_value}.  The value itself must describe the relationship between the abstract parameter \textsf{new\_value} and the new parameter \textsf{new\_value\_colors}.  As we use the parameter as the new value for the variable \textsf{cars\_colors}, the witness is an adaptation of the gluing invariant (we just replace \textsf{cars\_colors} with \textsf{new\_value\_colors}.

\info{In most cases, the witness is a slightly modified gluing invariant.}

Here is the resulting event:

\pencil{
\begin{description}
	\EVT {set\_cars\_colors}
	\REF {set\_cars}
		\begin{description}
		\AnyPrm
			\begin{description}
			\ItemX{ new\_value\_colors }
			\end{description}
		\WhereGrd
			\begin{description}
			\nItemX{ grd1 }{ new\_value\_colors \subseteq  COLORS }
			\nItemX{ grd2 }{ green \in  new\_value\_colors \limp  peds\_colors = red }
			\end{description}
		\Witnesses
			\begin{description}
			\nItem{ new\_value }{ new\_value = TRUE \leqv  green \in  new\_value\_colors }
			\end{description}
		\ThenAct
			\begin{description}
			\nItemX{ act1 }{ cars\_colors :=  new\_value\_colors }
			\end{description}
		\EndAct
		\end{description}
\end{description}
}

Even though all proof obligations are now discharged, we're not done yet: While the traffic light doesn't violate the safety property from the abstract machine, it doesn't behave the way described in Section~\ref{data_refinement}.  We still have to ensure that the lights are activated in the proper sequence.  We can impose this behavior by adding four guards, with each guard defining one transition:

\pencil{
\begin{description}
\nItemX{ grd\_y\_r }{ cars\_colors = \{  yellow \}  \limp  new\_value\_colors = \{  red \}  }
\nItemX{ grd\_r\_ry }{ cars\_colors = \{  red \}  \limp  new\_value\_colors = \{  red, yellow \}  }
\nItemX{ grd\_ry\_g }{ cars\_colors = \{  red, yellow \}  \limp  new\_value\_colors = \{  green \}  }
\nItemX{ grd\_g\_y }{ cars\_colors = \{  green \}  \limp  new\_value\_colors = \{  yellow \}  }
\end{description}
}

\subsection{Discussion}

Note that we used two very different approaches to model the traffic lights for cars and pedestrians.  For the pedestrians, we created one event for each state transition.  For the cars, we handled all states in one single event.

You will often be confronted with situations where many modelling approaches are possible.  You should consider two main factors when modelling: (1) readability of the model and (2) ease of proof.  In this case, both approaches are equally good (although we wouldn't recommend mixing different approaches in one model.  We did it here only to demonstrate both approaches).

We won't cover deadlocks (\ref{deadlock}) and deadlock freedom in this tutorial; however, we want to point out that the traffic light for the cars is interesting regarding deadlocks.  Consider \textsf{cars\_colors = \{ green, red \}}. This is a legal state, but it would block \textsf{set\_cars\_colors} forever!  A model checker (like ProB (\ref{prob}) could find it.  This is not a problem, however, as with the given initialization and events, that state is not reachable in the first place.

We hope that this Section helped you to understand the power of abstraction.  The safety invariant from Section~\ref{tutorial:invariants} was very simple.  We could now introduce colors, being confident that the invariant will still hold (assuming, of course, that our gluing invariant is correct).

\subsection{The Refined Machine with All Data Refinement}

\pencil{
\begin{description}
\MACHINE{mac1}
\REFINES{mac0}
\SEES{ctx1}
\VARIABLES
	\begin{description}
		\Item{ peds\_colors }
		\Item{ cars\_colors }
	\end{description}
\INVARIANTS
	\begin{description}
		\nItemX{ inv4 }{ peds\_colors \in  \{  red, green \}  }
		\nItemX{ inv5 }{ cars\_colors \subseteq  COLORS }
		\nItemX{ gluing\_peds }{ peds\_go = TRUE \leqv  peds\_colors = green }
		\nItemX{ gluing\_cars }{ cars\_go = TRUE \leqv  green \in  cars\_colors }
	\end{description}
\EVENTS
	\INITIALISATION
		\begin{description}
		\BeginAct
			\begin{description}
			\nItemX{ init4 }{ peds\_colors :=  red }
			\nItemX{ init5 }{ cars\_colors :=  \{  red \}  }
			\end{description}
		\EndAct
		\end{description}
	\EVT {set\_peds\_green}
	\REF {set\_peds\_go}
		\begin{description}
		\WhenGrd
			\begin{description}
			\nItemX{ grd1 }{ green \notin  cars\_colors }
			\end{description}
		\ThenAct
			\begin{description}
			\nItemX{ act2 }{ peds\_colors :=  green }
			\end{description}
		\EndAct
		\end{description}
	\EVT {set\_peds\_red}
	\REF {set\_peds\_stop}
		\begin{description}
		\BeginAct
			\begin{description}
			\nItemX{ act1 }{ peds\_colors :=  red }
			\end{description}
		\EndAct
		\end{description}
	\EVT {set\_cars\_colors}
	\REF {set\_cars}
		\begin{description}
		\AnyPrm
			\begin{description}
			\ItemX{ new\_value\_colors }
			\end{description}
		\WhereGrd
			\begin{description}
			\nItemX{ grd1 }{ new\_value\_colors \subseteq  COLORS }
			\nItemX{ grd2 }{ green \in  new\_value\_colors \limp  peds\_colors = red }
			\nItemX{ grd\_y\_r }{ cars\_colors = \{  yellow \}  \limp  new\_value\_colors = \{  red \}  }
			\nItemX{ grd\_r\_ry }{ cars\_colors = \{  red \}  \limp  new\_value\_colors = \{  red, yellow \}  }
			\nItemX{ grd\_ry\_g }{ cars\_colors = \{  red, yellow \}  \limp  new\_value\_colors = \{  green \}  }
			\nItemX{ grd\_g\_y }{ cars\_colors = \{  green \}  \limp  new\_value\_colors = \{  yellow \}  }
			\end{description}
		\Witnesses
			\begin{description}
			\nItem{ new\_value }{ new\_value = TRUE \leqv  green \in  new\_value\_colors }
			\end{description}
		\ThenAct
			\begin{description}
			\nItemX{ act1 }{ cars\_colors :=  new\_value\_colors }
			\end{description}
		\EndAct
		\end{description}
\END
\end{description}
}

\subsection{One more Refinement: The Push Button}

We will demonstrate another application of refinement: Introducing new features into an existing model.  A typical traffic light system allows the pedestrians to request crossing the street by pressing a button.  We will introduce this feature in a new refinement.

While we could have introduced the push button in the initial machine, introducing it later allows us to structure the model, making it easier to understand and navigate.

We will realize this feature by introducing a new boolean variable for the push button.  We will introduce an event that notifies the model of the pressing of the push button.  Upon allowing the pedestrians to cross, we will reset the push button.

As in the previous Section, we create a new refinement \textsf{mac2} by right-clicking on \textsf{mac1} and selecting \textsf{Refine}.  A stub is generated that contains the events from the abstract machine.  We can simply add a new variable for the push button (including typing and initialization).  We also introduce an event to set the button.  This event doesn't work while the pedestrians have a green light.

\pencil{
\begin{description}
\VARIABLES
	\begin{description}
		\Item{ button }
	\end{description}
\INVARIANTS
	\begin{description}
		\nItemX{ type\_button }{ button \in  BOOL }
	\end{description}
\EVENTS
	\INITIALISATION
		\\\textit{extended}
		\begin{description}
		\BeginAct
			\begin{description}
			\nItemX{ init\_button }{ button :=  FALSE }
			\end{description}
		\EndAct
		\end{description}
	\EVT {push\_button}
		\begin{description}
		\WhenGrd
			\begin{description}
			\nItemX{ grd }{ peds\_colors = red }
			\end{description}
		\ThenAct
			\begin{description}
			\nItemX{ act }{ button :=  TRUE }
			\end{description}
		\EndAct
		\end{description}
	\END
\end{description}
}

What's left now is the integration of the push button with the traffic light logic.  This includes:
\begin{itemize}
	\item Upon pressing the button, the pedestrians must eventually get a green light
	\item At some point, the button variable must be reset
\end{itemize}

As we will see in the following discussion, this can get more tricky than it first appears.  For now, we will introduce a guard preventing the car lights to turn to green when button is true.  And we will reset the button when the pedestrian lights turn red:

\pencil{
\begin{description}
	\EVT {set\_peds\_red}
	\EXTD {set\_peds\_red}
		\begin{description}
		\BeginAct
			\begin{description}
			\nItemX{ act\_button }{ button :=   FALSE }
			\end{description}
		\EndAct
		\end{description}
	\EVT {set\_cars\_colors}
	\EXTD {set\_cars\_colors}
		\begin{description}
		\WhereGrd
			\begin{description}
			\nItemX{ grd\_button }{ \lnot  (cars\_colors = \{  red \}  \land  button = TRUE) }
			\end{description}
		\EndAct
		\end{description}
\end{description}
}

\subsection{Discussion}

There are a number of problems associated with the model in its current state.  Let's start with the resetting of the button: The way we built our model so far, \textsf{set\_peds\_red} can be triggered any time - there is not a single guard, neither in the abstract event.  Therefore, the button could be reset any time, without the pedestrian light ever turning green.

This could be prevented with additional guards - for instance, the traffic light events could require an actual change in the light's status.  This in turn could lead to deadlocks.

But even if we introduce such guards, we could get stuck in a situation where cars would never get green light any more.  Consider the following scenario: (1) pedestrians get green light; (2) the light turns red; (3) a pedestrian presses the button again; (4) this prevents the car lights from turning green, instead the pedestrians get green light again and the cycle can start over.

There are tactics to address all these issues.  However, rarely is it possible to generate proof obligations for such scenarios (without making the model much more complicated).  It can be useful to use model checkers \ref{model_checker} to validate the model's behaviour, or even to use temporal logic \ref{temporal_logic} to articulate properties of the model.

\info{As an exercise, try to improve the model to address these issues.}

