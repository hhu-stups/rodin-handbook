\newcommand{\lascii}[1]{\qquad\quad \textrm{ASCII: } \texttt{#1}}
\newcommand{\inascii}[1]{(ASCII: \texttt{#1})}

\section{Mathematical notation}
\label{tut_mathematical_notation}
\index{mathematical notation}
\tick{\textbf{Goals:} In order to understand how basic properties of a model can be expressed in Event-B, we need a brief introduction of predicates, terms and data types.}
In Event-B, we use a mathematical notation to describe the systems we want to model.
This allows us to be very precise about the model's properties.

\subsection{Predicates}
\label{tut_predicates}
\index{predicate}
In the traffic light example, we have already encountered several predicates: The invariants of a model and the guards of an event. The proof obligations generated by Rodin are also predicates.  A predicate is simply an expression that evaluates to true or false.

The simplest predicates are $\btrue$ \inascii{true} and $\bfalse$ \inascii{false}.
We can also assert if arbitrary objects of the same type are equal with $=$ or not equal with $\neq$
\inascii{/=}.
Predicates can be combined with the usual logical operators:
\begin{center}
  \begin{tabular}{lcc}
                      & symbol   & ASCII \\
    \hline
    conjunction (and) & $\land$  & \texttt{\&} \\
    disjunction (or)   & $\lor$   & \texttt{or} \\
    implication       & $\limp$  & \texttt{=>} \\
    equivalence       & $\leqv$  & \texttt{<=>} \\
    negation (not)    & $\lnot$  & \texttt{not} \\
  \end{tabular}
\end{center}
We can use \emph{universal quantification} to express a statement that should hold for all possible values
a variable might have. For example, in order to show that any given number $x$ greater than zero and multiplied with two is greater than one, we can use the following expression: 
\[ \forall x \qdot x>0 \limp 2\cdot x > 1 \lascii{!x.\ x>0\ =>\ 2*x\ >\ 1}\]
When a variable is introduced by a quantifier, the type of the variable must be clear. In this case Rodin can infer that $x$ must be of type integer because the operator $<$ is defined only on integers. Sometimes the type cannot be inferred, e.g., in
\[ \forall a,b \qdot a\neq b \limp b\neq a \lascii{!a,b.\ a/=b\ =>\ b/=a} \]
$a$ and $b$ could be integers, boolean values or some other type.
In this case, we must make the type of the variables explicit by stating that $a$ and $b$ are elements
of the appropriate sets. Let's use integers again:
\[ \forall a,b \qdot a\in\intg \land b\in\intg \land a\neq b \limp b\neq a \lascii{!a,b.\ a:INT \& b:INT \& a/=b => b/=a} \]
The conjunction operator ($\land$) has a stronger binding that the implication $\limp$, so the above is equivalent to
\[ \forall a,b \qdot (a\in\intg \land b\in\intg \land a\neq b) \limp b\neq a\]

\warning{
If you are unsure which of the operators bind stronger, we advise you to use parenthesis to avoid mistakes.
}

\emph{Existential quantification} on the other hand is used to state that there is an object of a certain type fulfilling a given property. Let's express the statement that there is a Boolean value different from
$\True$.
\[ \exists x \qdot x\in\Bool \land x\neq\True \lascii{\#x.\ x:BOOL\ \&\ x/=TRUE} \]
As you can see, we again added type information for $x$. We put the type information for the universal quantification on the left side of the implication ($\limp$), but
for existential quantification we add it via a conjunction ($\land$).

\subsection{Data types}
\label{tut_data_types}
\index{data type}
We have seen that each identifier (i.e. a variable, constant or parameter) must have a distinguished type.
If we can introduce an identifier anywhere, we usually must also add a predicate with which the
identifier's type can be determined. In the traffic light example, a variable \texttt{cars\_go} was
introduced and typed by an invariant $cars\_go \in \Bool$. In the next section, we'll see constants that
will be typed by axioms (also predicates) and later we'll see parameters that will be typed by guards (again, predicates).

As a rule, each term in Event-B must have a certain type. 
When saving a Event-B component, Rodin starts the type checker to ensure that types are correctly used. For example, the terms on both sides of an equality ($=$) must have the same type. If this is not the case, Rodin will generate an error message.
For each type there exists a set that denotes exactly all elements that belong the type. We will now briefly
give an overview about all types you might encounter.

\begin{description}
\item[Integers] 
\index{integer}
\index{data type!integer}
  We have already seen numbers, which are of type integer ($\intg$).
  Example terms of type $\intg$ are $5$, $x+7$ and $7 \cdot y - 3$.
\item[Booleans]
\index{boolean!as type}
\index{data type!boolean} 
  We have already seen the Boolean type ($\Bool$) in the previous section (\ref{tut_first_machine}).
  It has exactly two elements, $\Bool = \{\True,\False\}$.
\item[Carrier sets]
\index{carrier set} 
\index{data type!carrier set}
  An user can introduce a new type by adding its name to the
  \textsf{Sets} section of a context. We see that in more detail in the next section (\ref{tut_contexts}).
\item[Sets]
\index{set!as type}
  If we have terms of a certain type, we can easily construct sets of that type.
  E.g. $1$ and $2\cdot x$ denote integers ($\intg$) and $\{1,2\cdot x\}$ is a set of integers ($\pow(\intg)$).
  $\pow(S)$ \inascii{POW} denotes the power set (the set of all subsets) of $S$.
\item[Pairs]
\index{pair} 
  If we have two terms, we can construct a pair. For example, with $2$ and $\True$, we
  can construct the pair $2\mapsto\True$ \inascii{2|->TRUE}.
  The type of that pair is $\intg\cprod\Bool$, where $\cprod$ denotes the Cartesian product.

  Set of pairs (``relations'') play an important role in modeling languages like Event-B.
\end{description}

\warning{Please do not confuse predicates and Boolean values!
  For example, if you want to express the condition ``if the variable $b$ is true, $x$ should be greater than 2'', you \emph{cannot} 
  write $b \limp x>2$ (That would raise a syntax error). 
  Instead you can write $b = \True \limp x>2$.}

In the reference section (\ref{mathematical_notation}) the types of each operator in Event-B are described in detail.

\subsection{Operations on Sets}
\label{tut_operations_on_sets}
\index{set!operations}
Let's assume that we have two sets $A$ and $B$ of the same type, e.g. sets of integers.
Then we can check if an element $e$ is in it by $e\in A$ \inascii{e:A} or 
on if it is not in $A$ by $e\notin A$ \inascii{e/:A}.
Expressing that all elements of $A$ are also elements of $B$ (i.e. $A$ is a subset of $B$) can
be done by $A\subseteq B$ \inascii{A<:B}. The negated form is $A\not\subseteq B$ \inascii{A/<:B}.

We can build the union $A\cup B$, the intersection $A\cap B$ and the set subtraction $A\setminus B$,
(ASCII: \texttt{A\mybackslash{}/B}, \texttt{A/\mybackslash{}B} and \texttt{A\mybackslash{}B}). The
set subtraction contains all elements that are in $A$ but not in $B$.

The power set $\pow(A)$ \inascii{POW(A)} is the set of all subsets of $A$.
Thus $B\in\pow(A)$ is equivalent to $B\subseteq A$.
$\pow_1(A)$ \inascii{POW1(A)} is the set of all non-empty subsets of $A$.

\subsection{Introducing user-defined types}
\label{tut_user_defined_sets}
\index{data type!user defined}

We can introduce our own new types simply by giving such types a name.
This is done by adding the name of the type to the \textsl{SETS} section of a context.
We will see how this is done in practice in the next section (\ref{tut_contexts}).

For instance, if we want to model different kind of fruits in our model, we might add $FRUITS$ to our
sets. Then the identifier $FRUITS$ denotes the set of all elements of this type. Nothing more is known about $FRUITS$ unless we add further axioms. In particular, we do not
know the cardinality of the set or even if it is finite.

\warning{Assume that we want to model $apples$ and $oranges$ which are sub-sets of $FRUITS$.
  We do not need to introduce them in the \textsl{SETS} section of a context just because they are sets.
  Let's imagine such a scenario where $apples$ and $oranges$ are modeled
  as types of their own (by declaring them in the \textsl{SETS} section).
  And we have two variables or constants $a$ and $o$ with $a\in apples$ and $o\in oranges$. 
  Then we cannot compare $a$ and $o$ with $a=o$ or $a\neq o$. That would raise a type error because
  $=$ and $\neq$ expect the same type for the left and right expression.}

If we want to model sub-sets $apples$ and $oranges$ as described above, we can add them as
constants and state $apples \subseteq FRUITS$ and $oranges \subseteq FRUITS$.
If apples and oranges are all fruits we want to model, we can assume $apples \cup oranges = FRUITS$
and if no fruit is both an apple and orange we can write $apples \cap oranges = \emptyset$.
This can be expressed shorter by saying that apples and oranges constitute a
partition of the fruits: $partition(FRUITS,apples,oranges)$.
In general, we can use the partition operator to express that a set $S$ is partitioned by the
sets $s_1,\ldots,s_n$ with $partition(S,s_1,\ldots,s_n)$.  We use partitions in Section~\ref{tut_modelling_persons}.

Another typical usage for user defined data types are \emph{enumerated sets}.
These are sets where we know all the elements already. Let's take a system which can be either working or broken.
We model this by introducing a type $STATUS$ in the \textsl{SETS} section and two constants
$working$ and $broken$.
We define that STATUS consists of exactly $working$ and $broken$ by $STATUS = \{working,broken\}$.
Additionally, we have to say that $working$ and $broken$ are not the same by $working \neq broken$.

If the enumerated sets gets larger, we need to state for every two element of the set that they are
distinct. Thus, for a set of 10 constants, we'll need $(10^2-10)\div 2 = 45$ predicates.
Again, we can use the partition operator to express this in a more concise way: $partition(STATUS,\{working\},\{broken\})$.

\subsection{Relations}
\label{tut_relations}
\index{relation}
Relations are a powerful instrument when modeling systems. From a mathematical point of view a
relation is just a set of pairs. Formally, when we have to sets $A$ and $B$, we can specify that
$r$ is a relation between both by $r \in \pow(A\cprod B)$ \inascii{r:POW(A**B)}.
Because relations are so common, we can write it shorter $r \in A\rel B$ \inascii{r:A<->B}.

With $a\mapsto b\in r$, we can check if two elements $a$ and $b$ are related in respect to $b$.

We use a small example to illustrate relations. Let $A = \{a,b,c,d\}$ and $B=\{1,2,3,4\}$.
We define the relation $r$ with $r = \{a\mapsto 1, a\mapsto 3, c\mapsto 2, d\mapsto 1\}$.
The \emph{domain} of $r$ are all elements occurring on the left side $\dom(r) = \{a,c,d\}$ and the
\emph{range} are all elements on the right $\ran(r)=\{1,2,3\}$.

To find out to which elements the objects of the set $s=\{b,c,d\}$ are related to, we can use the \emph{relational image}:
$r[s] = r[\{b,c,d\}] = \{1,2\}$.
Often we want to know to which object a single element $b$ is related. We just write it as a singleton
set: $r[\{a\}] = \{1,3\}$.

Event-B supports several operators to work with relations. (\ref{relations})
We will not go into more detail during the course of the tutorial.

An important special case of relations are functions. Functions are relations where each element of the
domain is uniquely related to one element of the range. Event-B directly supports operators to describe
partial and total functions, which can injective, surjective or bijective.

\subsection{Arithmetic}
\label{tut_arithmetic}
\index{arithmetic}
We have the usual operations on integers, $+$, $-$, $\cdot$ and $\div$ (ASCII: \texttt{+}, \texttt{-},
\texttt{*} and \texttt{/}). They can be compared with the usual $<$, $\leq$, $\geq$, $>$ (ASCII: \texttt{<}, \texttt{<=}, \texttt{>=}, \texttt{>}).

$\intg$ \inascii{INT} denotes the set of all integer numbers. $\nat$ and $\nat_1$ (ASCII: \texttt{NAT} resp. 
\texttt{NAT1}) are the subsets of natural numbers.

\info{If you specify two variables $x$ and $y$ with $x\in\intg$ and $y\in\nat$, then both are of type
integer ($\intg$). $\nat$ is not another type. There is just the additional condition $y \geq 0$.}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "rodin-doc"
%%% End: 
