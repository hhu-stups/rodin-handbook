\chapter{Tutorial}
\label{tutorial}

This tutorial should provide the user with a tour through the most important functionalities of RODIN, so that he gets a understanding of how the program works.

The tutorial doesn't contain all the knowledge that you require.  Instead, it touches upon every concept - from installation to set theory to modeling and refinement - and helps you to find gaps in your knowledge.

Before we build a first model, we will cover some basic math.

\section{Tutorial Proposal (WP1-4)}

These are the chapters of the tutorial.  Average time available to write each chapter: 5 hours.  This is not much time.  Therefore, make sure that the sceleton exists before filling in details.  This is particularly true for screenshots: By all means indicate where screenshots should be, but don't waste time on them until the end.

\begin{description}
	\item[Background before getting started] -- we give a brief description of what Event-B is and what it is being used for; what kind of background knowledge we expect.
	\item[Installation] -- Guiding the user through downloading, installing and starting Rodin; Point out platform differences.  Install the provers.  Name the visible views and describe what they are doing.
	\item[Hello, world] -- a first machine, e.g. a traffic light with booleans for signals.  We introduce guards, resulting in the proof obligations to be discharged automatically. We explain how proof lables are read, without changing to the proof perspective.
	\item[Mathematical notation] -- At this point we quickly go through the most important aspects of predicate calculus and provide pointers to the reference and to external literature
	\item[Introducing Contexts] -- a little context-only example, but not too mathematical.  E.g. a data structure with axioms to show that it is a tree. Point out partitions as a typical pitfall (also add to FAQ)
	\item[Combining contexts and machines] -- introducing the ``sees'' relationship.
	\item[Refinement] -- introducing a refinement to add a new feature - the call button, for instance.
	\item[Theory behind refinement] -- describe what refinement means mathematically.
	\item[Data refinement] -- introduce data refinement (boolean to traffic light colors
	\item[Witnesses] -- What they are and how to work with them.  We need an example
	\item[Proving] -- hopefully, so far all proof obligations were discharged automatically.  Now we switch for the first time to the prooving perspective and explore it.  We change the auto prover configuration, invalidate proofs and show, that with the new configuration they don't discharge any more.  We prove a simple proof by hand.  We describe the provers available.
	\item[Tricky Proving] -- we start with a new example that contains a difficult proof.  We walk the user through discharging the proof with plenty of screen shots.
	\item[Complete Abrial Example] -- we pick an interesting example from the Abrial book, if we get permission.
	\item[Outlook] -- This concludes the tutorial, but we will provide many pointers to the user.  In particular, we will point to the literature from the deploy project, the Wiki and to plugins that solve specific problems.
\end{description}

\section{Theory to Get You Started}
\label{tutorial_theory}

\tick{\textbf{Goals:} The focus of this section is to briefly cover all the required theory, and to provide pointers for further reading.  Specifically, this includes Propositional Calculus, First Order Predicate Calculus, Set Theory and Arithmetic}

\paragraph{See Also:}
\begin{itemize}
\item Mathematical Notation Slides \url{files/sld_mth1.pdf}
\end{itemize}


\section{Getting around Rodin}
\label{tutorial_2}

\tick{\textbf{Goals:} In this section, we cover installation, the basic features of an Eclipse application, and the Rodin-specific GUI elements.}


\section{Example 1: A Trafficlight Controller}
\label{tutorial_3}

\tick{\textbf{Goals:} The focus of this section is modeling.  You will learn how to model a simple system (a traffic light controller).  We will use this example to introduce the concept of refinement (\ref{refinement}).  The proofs in this section should all be discharged automatically. }

The following picture visualizes the problem we are going to solve:

\begin{center}
	\includegraphics[width=0.9\textwidth]{img/tutorial/trafficlight.png}
\end{center}

The objective is to design the software for a controller that switches the trafficlights and that reacts to pedestrian requests to cross the street.

We tackle the problem in multiple steps:

\begin{enumerate}
	\item We will abstract the problem and develop a refinement plan (\ref{tutorial_tl_problem_abstraction})
	\item We will implement the initial model (\ref{tutorial_tl_initial_model})
	\item We will perform Data Refinement (\ref{data_refinement})
\end{enumerate}

\subsection{Problem Abstraction}
\label{tutorial_tl_problem_abstraction}

\subsection{Initial Model}
\label{tutorial_tl_initial_model}

\subsubsection{Project Setup}

First create a new Event-B Project \textsf{File $\rangle$ New $\rangle$ Event-B Project}.  Give the project the name \texttt{trafficlight}.

Next, create a Machine.  Right-click the newly created project and select \textsf{New $\rangle$ Event-B Component}.  Call the component \texttt{mac0}.

\info{A good naming convention can save a lot of work.  We have a recommended naming convention (\ref{naming_convention})}

\subsubsection{System State}

We will now add the variables that store the traffic light value as a boolean.

\tick{A new variable requires three elements: The variable itself, the typing invariant and the initialization.  But typically, we'd also add events that change the state.  And there may be further invariants constraining the state.}



\pencil{
\begin{description}
\VARIABLES
	\begin{description}
		\Item{ cars\_go }
	\end{description}
\INVARIANTS
	\begin{description}
		\nItemX{ inv1 }{ cars\_go \in  BOOL }
	\end{description}
\EVENTS
	\INITIALISATION
		\begin{description}
		\BeginAct
			\begin{description}
			\nItemX{ act1 }{ cars\_go :=  FALSE }
			\end{description}
		\EndAct
		\end{description}
\END
\end{description}
}


\info{There are various ways to accelerate the creation of variables.  The structural editor has a wizard for this purpose.}

\pencil{
\begin{description}
\MACHINE{mac0}
\VARIABLES
	\begin{description}
		\Item{ cars\_go }
		\Item{ peds\_go }
	\end{description}
\INVARIANTS
	\begin{description}
		\nItemX{ inv1 }{ cars\_go \in  BOOL }
		\nItemX{ inv2 }{ peds\_go \in  BOOL }
		\nItemX{ inv3 }{ \lnot  (cars\_go = TRUE \land  peds\_go = TRUE) }
	\end{description}
\EVENTS
	\INITIALISATION
		\begin{description}
		\BeginAct
			\begin{description}
			\nItemX{ act1 }{ cars\_go :=  FALSE }
			\nItemX{ act2 }{ peds\_go :=  FALSE }
			\end{description}
		\EndAct
		\end{description}
	\EVT {cars\_light}
		\begin{description}
		\AnyPrm
			\begin{description}
			\ItemX{ new\_value }
			\end{description}
		\WhereGrd
			\begin{description}
			\nItemX{ grd1 }{ \lnot  (new\_value = TRUE \land  peds\_go = TRUE) }
			\end{description}
		\ThenAct
			\begin{description}
			\nItemX{ act1 }{ cars\_go :=  new\_value }
			\end{description}
		\EndAct
		\end{description}
	\EVT {peds\_light}
		\begin{description}
		\AnyPrm
			\begin{description}
			\ItemX{ new\_value }
			\end{description}
		\WhereGrd
			\begin{description}
			\nItemX{ grd1 }{ \lnot  (cars\_go = TRUE \land  new\_value = TRUE) }
			\end{description}
		\ThenAct
			\begin{description}
			\nItemX{ act1 }{ peds\_go :=  new\_value }
			\end{description}
		\EndAct
		\end{description}
\END
\end{description}
}

\subsection{Data Refinement: Introduce Trafficlight Colors}
\label{tutorial_tl_data_refinement}


- simple proofs
- refinement

\section{Excurs: Data Structures}
\label{tutorial_4}

\section{Excurs: Proofing}
\label{tutorial_5}

\section{A more complex Example}


