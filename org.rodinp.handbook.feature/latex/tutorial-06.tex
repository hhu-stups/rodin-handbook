\newcommand{\eventbpo}[1]{\textsf{#1}}

\section{Event-B Concepts}
\label{tutorial_06}

In Event-B we have two kind of components.
We already encountered a \emph{context} that describes static elements of a model.
The other component is a \emph{machine} that describes the dynamic behavior of a model.

\subsection{Contexts}
\label{tutorial:contexts}

A context has the following components:
\begin{description}
\item[Sets]
  User-defined types can be declared in the \textsl{SETS} section
  (See also \ref{tutorial:user_defined_sets}).
\item[Constants]
  We can declare constants here. The type of each constant must be given
  by the axioms.
\item[Axioms] The axioms are a list of predicates. 
  They describe what can be taken for granted when developing a model.
  The axioms can be later used in proofs that occur in components that
  use (``\emph{see}'') this context.
  Each axiom has a label attached to it.
\item[Theorems] 
  Axioms can be marked as \emph{theorems}. In that case, we declare that
  the predicate is provable by using the axioms that are written 
  before the theorem.
  Theorems can be used later in proofs just like the axioms.
\item[Extends]
  A context may extend an arbitrary number of other contexts.
  Extending another context $A$ has the effect that we can make use of
  all constants and axioms declared in $A$ and we can add new constants
  and axioms.
\end{description}
Rodin automatically generates \emph{proof obligations} (often abbreviated as PO) for properties that
should be proven. Each proof obligation has a name that explains where it comes from.
There are two kind of proof obligations generated in a context:
\begin{itemize}
  \item Each theorem must be proven. The proof obligation's name has the form 
    \eventbpo{label/THM}, where \eventbpo{label} is the theorem's label.
  \item Some expressions are not obviously \emph{well-defined}.
    E.g. the axiom $x \div y > 2$ is only meaningful if $y$ is different from 0.
    Thus Rodin generates the proof obligation $y\neq 0$.
    A well-defined proof obligation has the name \eventbpo{label/WD}.
\end{itemize}
The order of the axioms and theorems matter because the proof of a theorem or the degree to which an expression is well-definded may depend on the axioms and theorems that are already written. This is necessary to avoid circular reasoning.


\subsection{Machines}
\label{tutorial:machines}

A machine describes the dynamic behavior of a model by means of
variables whose values are are changed by events.
A central aspect of modeling a machine is to prove that the machine
never reaches an invalid state, i.e. the variables always have values
that satisfy the invariant.
First we briefly summarize of which parts a machine consists:

\begin{description}
\item[Refines] Optionally a machine can refine another one.
  We'll see in \ref{tutorial:refinement} what that means.
\item[Sees] We can use the context's sets, constants and axioms  in
  a machine by declaring it in the \textsl{Sees} section.
  The axioms can be used in every proof in the machine as hypothesis.
\item[Variables]
  The variables' values are determined by an initialization and
  can be changed by events. Together they constitute the state
  of the machine.
  Each variable must be given a type by the invariants.
\item[Invariants]
  This are predicates that should be true for every reachable state.
  Each invariant has a label.
\item[Events]
  An event can assign new values to variables.
  The \emph{guards} of an event specify under which conditions it might occur.
  The initialization of the machine is a special case of an event.
\end{description}

\subsection{Events}
\label{tutorial:events}

We saw in \ref{tutorial_03} how an event basically looks like using the example of a traffic light:
\begin{description}
	\EVT {set\_cars}
		\begin{description}
		\AnyPrm
			\begin{description}
			\ItemX{ new\_value }
			\end{description}
		\WhereGrd
			\begin{description}
			\nItemX{ grd1 }{ new\_value \in  BOOL }
			\end{description}
		\ThenAct
			\begin{description}
			\nItemX{ act1 }{ cars\_go :=  new\_value }
			\end{description}
		\EndAct
		\end{description}
\end{description}
We have the event's name $set\_cars$, a \emph{parameter} with the name $new\_value$,
a \emph{guard} with label grd1 and an \emph{action} with label act1.
An event can have an arbitrary number of parameters, guards and events.

The guards specify \emph{when} an event might occur, i.e. under which combinations
of the values of the machine's variables and the parameters.
The actions describe \emph{what} changes apply to the variables.

Only the variables that are explicitly mentioned in the actions are affected.
All the other variables keep their old values. Beside the simple assignment ($\bcmeq$),
there are other forms of actions ($\bcmin$ or $\bcmsuch$) which are explained in
the reference section \ref{actions}.

The \emph{initialization} of the machine is a special form of event. It has neither parameters
nor guards.

Now our aim is to prove that the invariants always hold. To do this, we must prove two things:
\begin{itemize}
  \item The initialization leads to a state where the invariant holds.
  \item Assuming that the machine is in a state where the invariant holds,
    every enabled event leads to a state where the invariant holds.
\end{itemize}

Rodin generates proof obligations for every invariant that can be changed by an event, i.e. the invariant contains variables changed by an event.
The name of the proof obligation is then \eventbpo{event\_name/invariant\_label/INV}.
The goal of such a proof is to assert that when all affected variables are replaced by new values from the actions, the invariant still holds. The hypotheses for such a proof obligation consist of:

\begin{itemize}

\item All invariants, because we assume that all invariants hold before the event is triggered,
\item All guards, because events can only be triggered when the guards are valid.
\end{itemize}

In the special case of an initialization, we cannot use the invariants because we do not
make any assumptions about uninitialized machines.

\subsection{Refinement}
\label{tutorial:refinement}
Refinement is a central concept in Event-B. Refinements are used to gradually
introduce the details and complexity into a model.
If a machine \texttt{B} refines a machine \texttt{A}, \texttt{B} is only allowed to behave in a way that
corresponds to the behavior of \texttt{A}. We now look into more detail of what ``corresponds''
here means.
In such a setting, we call \texttt{A} the abstract and \texttt{B} the concrete machine.

Here we give just a brief overview over the concept of refinement. Later in Section \ref{tutorial_07}
we use refinement in an example.

The concrete machine has its own set of variables. Its invariants can refer to
the variables of the concrete and the abstract machine. If a invariant refers to both,
we call it a ``gluing invariant''. The gluing invariants are
used to relate the states between the concrete and abstract machines.

The events of a concrete machine can now refine an abstract event. To ensure that the concrete machine 
does only what is allowed by the abstract one, we must show two things:
\begin{itemize}
\item The concrete events can only occur when the abstract one can occur.
\item If a concrete event occurs, the abstract event can occur in such a way that the resulting
  states correspond again, i.e. the gluing invariant remains true.
\end{itemize}

The first condition is called ``guard strengthening''. The resulting proof obligation has the label
\eventbpo{concrete\_event/abstract\_guard/GRD}. We have to prove that under the assumption that the
concrete event is enabled (i.e. its guard are true) and the invariants (both the abstract and the concrete) 
hold, the abstract guards holds as well. Thus the goal is to prove that the abstract guard, the invariants and the
concrete guards can be used as hypothesis in the proof.

The second condition, that the gluing invariant remains true, is just a more general case of the proof obligation which ensures 
that an event does not violate the invariant. So the proof obligation's label is again 
\eventbpo{concrete\_event/concrete\_invariant/INV}. The goal is to prove that the invariant of the concrete machine is valid when each occurence of a modified variable is replaced by its new value.
The hypotheses we can use are:
\begin{itemize}
\item We assume that the invariant of both the concrete and abstract machines hold before the event occurred.
\item The abstract invariants where the modified variables are replaced by their new values are valid because we know that the abstract event does not violate the invariants.
\item The event occurs only when the guards of both the concrete and abstract machines are true.
\end{itemize}

These two conditions are the central piece to prove the correctness of a refinement. We now just explain a few
common special cases.

\subsubsection{Variable re-use}
\label{tutorial:variable_reuse}
Most often, we do not want replace all variables by new ones. It is sometimes useful to keep all of the variables.
We can do this just by repeating the names of the abstract variables in the variable section of the concrete
machine. In that case, we must prove for each concrete event that changes such a variable that the corresponding 
abstract event updates the variable in the same way.
The proof obligation has the name \eventbpo{concrete\_event/abstract\_action/SIM}.

\subsubsection{Introducing new events}
\label{tutorial:skip}
An event in the concrete machine might not refine any event in the abstract machine. In that case it is assumed
to refine \emph{skip}, which is the event that does nothing and can occur any time. 
The guard strengthening is then trivially true and doesn't need to be proven.
It still must be proven that the gluing invariant holds but this time under the assumption that the abstract machine's
variables have not changed. Therefore, the new state of our newly introduced event corresponds to the same state of
our abstract machine from before the event happened.

\subsubsection{Witnesses}
\label{tutorial:witnesses}
Let's consider a situation where we have an abstract event with a parameter $p$ and in a refining event that no longer needs that parameter.
We saw above that we have to prove that for each concrete event the abstract event may act accordingly.
With the parameter, however, we now have the situation that we must prove the existence of a value for $p$ such
that an abstract event exists. Proofs with existential quantification are often hard to do, so Event-b 
uses the construct of a \emph{witness}. A witness is just a predicate of the abstract parameter with the
name of the variable as label. Often a witness has just the simple form $p = \ldots$.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "rodin-doc"
%%% End: 
