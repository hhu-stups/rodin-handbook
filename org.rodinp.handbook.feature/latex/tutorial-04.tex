\newcommand{\lascii}[1]{\qquad\quad \textrm{ASCII: } \texttt{#1}}
\newcommand{\inascii}[1]{(ASCII: \texttt{#1})}

\section{Mathematical notation}
\label{tutorial_04}
\tick{\textbf{Goals:} We want to know how basic properties of a model can be expressed in Event-B.
  We need a brief introduction to predicates, terms and data types for that.}
In Event-B, we use a mathematical notation to describe the systems we want to model.
This allows us to be very precise about the model's properties.
Let's take ``$x>1$'' as an example. It contains two terms, $x$ and $1$ which represent objects
---in this case numbers--- and a predicate $x>1$ which can be true or false. 
%True predicates can usually be proven.

\subsection{Predicates}
\label{tut04:predicates}
In the traffic light example, we have already encountered several predicates: The invariants of
a model and the guards of an event. Also the proof obligations generated by Rodin are
predicates.

The simplest predicates are $\btrue$ \inascii{true} and $\bfalse$ \inascii{false}.
Also we can check if arbitrary objects of the same type are equal with $=$ resp. $\neq$
\inascii{/=}.
Predicates can be combined with the usual logical operators:
\begin{center}
  \begin{tabular}{lcc}
                      & symbol   & ASCII \\
    \hline
    conjunction (and) & $\land$  & \texttt{\&} \\
    disjuntion (or)   & $\lor$   & \texttt{or} \\
    implication       & $\limp$  & \texttt{=>} \\
    equivalence       & $\leqv$  & \texttt{<=>} \\
    negation (not)    & $\lnot$  & \texttt{not} \\
  \end{tabular}
\end{center}
We can use \emph{universal quantifiation} to express a statement that should hold for all possible values
a variable might have. E.g. we want to express that if a number $x$ is greater than zero,
then $x$ multiplied by 2 is greater than one:
\[ \forall x \qdot x>0 \limp 2\cdot x > 1 \lascii{!x.\ x>0\ =>\ 2*x\ >\ 1}\]
When a variable is introduced by a quantifier, the variables' type must be clear.
In this case Rodin can infer that $x$ must be of type integer, because the operator $<$ 
is defined only on integers. Sometimes the type cannot be infered, e.g in
\[ \forall a,b \qdot a\neq b \limp b\neq a \lascii{!a,b.\ a/=b\ =>\ b/=a} \]
$a$ and $b$ could be integers, Booleans or whatever.
In that case we must make the type of the variables explicit by stating that $a$ and $b$ are elements
of the appropiate sets. Let's use integers again:
\[ \forall a,b \qdot a\in\intg \land b\in\intg \land a\neq b \limp b\neq a \lascii{!a,b.\ a:INT \& b:INT \& a/=b => b/=a} \]
The conjunction operator ($\land$) has a stronger binding that the implication $\limp$, so the above is equivalent to
\[ \forall a,b \qdot (a\in\intg \land b\in\intg \land a\neq b) \limp b\neq a\]
If you are unsure which operators bind stronger, we advise you to use parenthesis to avoid mistakes.

\emph{Existential quantification} on the other hand is used to state that there is an object of a certain type that
fulfills a given property. Let's express the statement that there is a Boolean value that is different from
$\True$.
\[ \exists x \qdot x\in\Bool \land x\neq\True \lascii{\#x.\ x:BOOL\ \&\ x/=TRUE} \]
As you can see, we again added type information for $x$. Whereas we we put the type information in the universal
quantification on the left side of the implication ($\limp$), 
for existential quantification we add it via a conjunction ($\land$).

\subsection{Data types}
\label{tut04:types}
We have seen that each identifier (i.e. a variable, constant or parameter) must have an distinguished type.
If we can introduce an identifier anywhere, we usually must also add a predicate with which the
identifier's type can be determined. In the traffic light example, a variable \texttt{cars\_go} was
introduced and typed by an invariant $cars\_go \in \Bool$. In the next section we'll see constants that
will be typed by axioms (also predicates) and later we'll see paramters that will be typed by guards (again, predicates).

In general, each term in Event-B has a certain type. 
When saving a Event-B component, Rodin starts the type checker to ensure that types a correctly used.
E.g. the terms on both sides of an equality ($=$) must have the same type. If not, Rodin shows an error message.
For each type there exists a set that denotes exactly all elements that belong the type. We now briefly
give an overview about all types you might encounter.

\begin{description}
\item[Integers] 
  We have already seen numbers, wich are of type integer ($\intg$).
  Example terms of type $\intg$ are $5$, $x+7$ and $7 \cdot y - 3$.
\item[Booleans] 
  We have already seen the Boolean type ($\Bool$) in the previous section (\ref{tutorial_03}).
  It has exactly two elements, $\Bool = \{\True,\False\}$.
\item[Deferred sets] 
  An user can introduce a new type by adding its name to the
  \textsf{Sets} section of a context. We see that in more detail in the next section (\ref{tutorial_05}).
\item[Sets]
  If we have terms of a certain type, we can easily construct sets of that type.
  E.g. $1$ and $2\cdot x$ denote integers ($\intg$) and $\{1,2\cdot x\}$ is a set of integers ($\pow(\intg)$).
  $\pow(S)$ \inascii{POW} denotes the powerset (the set of all subsets) of $S$.
\item[Pairs] 
  If we have two terms, we can construct a pair, e.g. with $2$ and $\True$, we
  can construct the pair $2\mapsto\True$ \inascii{2|->TRUE}.
  The type of that pair is $\intg\cprod\Bool$, where $\cprod$ denotes the Cartesian product.

  Set of pairs (``relations'') play an important role in modeling languages like Event-B.
\end{description}

\warning{Please do not confound predicates and Boolean values!
  E.g. if you want to express the condition ``if the variable $b$ is true, $x$ should be greater than 2'', you \emph{cannot} write $b \limp x>2$. Instead you can write
  $b = \True \limp x>2$.
}

In the reference section (TODO: link to mathematical notation if the reference) the types of each operator in Event-B are described in detail.

\subsection{Operations on Sets}
\label{tut:operations_on_sets}
Let's assume that we have two sets $A$ and $B$ of the same type, e.g. sets of integers.
Then we can check if an element $e$ is in it by $e\in A$ \inascii{e:A} or 
on the contrary if it is not in $A$ is $e\notin A$ \inascii{e/:A}.
Expressing that all elements of $A$ are also elements of $B$ (i.e. $A$ is a subset of $B$) can
be done by $A\subseteq B$ \inascii{A<:B}. The negated form is $A\not\subseteq B$ \inascii{A/<:B}.

We can build the union $A\cup B$, the intersection $A\cap B$ and the set subtraction $A\setminus B$,
(ASCII: \texttt{A\mybackslash{}/B}, \texttt{A/\mybackslash{}B} and \texttt{A\mybackslash{}B}). The
set subtraction contains all elements that are in $A$ but not in $B$.

The powerset $\pow(A)$ \inascii{POW(A)} is the set of all subsets of $A$.
Thus $B\in\pow(A)$ is equivalent to $B\subseteq A$.
$\pow_1(A)$ \inascii{POW1(A)} is the set of all non-empty subsets of $A$.

(TODO: Partition)

% \subsection{Deferred Sets}
% \label{tut:deferred_sets}
% (TODO: Are they really called so in Event-B?)

% In the next section (\ref{tutorial_05}) we can see how new types can be introduced in the \textsf{Sets}
% section of a context. Let's assume that we want to specify a file system and want 

\subsection{Relations}
\label{tut:relations}
Relations are a powerful instrument when modeling systems. From a mathematical point of view a
relation is just a set of pairs. Formally, when we have to sets $A$ and $B$, we can specify that
$r$ is a relation between both by $r \in \pow(A\cprod B)$ \inascii{r:POW(A**B)}.
Because relations are so common, we can write it shorter $r \in A\rel B$ \inascii{r:A<->B}.

To check if two elements $a$ and $b$ stand in relation regarding $b$, we can write $a\mapsto b\in r$.

TODO: \ldots

\subsection{Arithmetic}
\label{tut:arithmetic}
We have the usual operations on integers, $+$, $-$, $\cdot$ and $\div$ (ASCII: \texttt{+}, \texttt{-},
\texttt{*} and \texttt{/}). And they can be compared whith the usual $<$, $\leq$, $\geq$, $>$ (ASCII: \texttt{<}, \texttt{<=}, \texttt{>=}, \texttt{>}).

$\intg$ \inascii{INT} denotes the set of all integer numbers, $\nat$ and $\nat_1$ (ASCII: \texttt{NAT} resp. 
\texttt{NAT1}) are the subsets of natural numbers).

\info{If you specify two variables $x$ and $y$ with $x\in\intg$ and $y\in\nat$, then both are of type
integer ($\intg$). $\nat$ is not another type. There is just the additional condition $y \geq 0$.}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "rodin-doc"
%%% End: 
